
<html>
<head>
<meta charset="UTF-8">
<title>Export Notes by xxhk.org</title>
<style>

body { font-family: Arial, sans-serif; }
.card { border: 2px solid #000; padding: 10px; border-radius: 10px; margin-bottom: 20px; }
img {
max-width: 100%;
height: auto;
border: 1px solid lightgray;
border-radius: 10px;
display: inline-block;
margin: 10px 0px;
}
.separator { border-top: 1px dashed #000; margin: 10px 0; }
.tags { background-color: lightgray; padding: 5px 10px; margin-bottom: 10px; border-radius: 5px; display: inline-block; }
.date { color: #666; font-size: 0.9em; margin-bottom: 5px; }
.footer {
text-align: center;
color: grey;
margin-top: 20px;
padding: 10px;
}
h1 { text-align: center; color: #333; margin: 20px 0; }

.video-container {
margin: 10px 0;
}
.video-placeholder {
position: relative;
cursor: pointer;
}
.play-button {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 68px;
height: 48px;
background-color: rgba(0, 0, 0, 0.7);
border-radius: 14px;
cursor: pointer;
}
.play-button::before {
content: '';
position: absolute;
top: 50%;
left: 55%;
transform: translate(-50%, -50%);
border-style: solid;
border-width: 12px 0 12px 20px;
border-color: transparent transparent transparent white;
}
.play-button:hover {
background-color: red;
}

</style>

</head>
<body>
<h2 aria-hidden="true" style="text-align: center;"><br>Wandering Osmosis with <a href="https://www.microsoft.com/zh-cn/edge/features/read-aloud?form=MA13FJ">Edge TTS</a><br><br>added:1<br><br></h2>
<div id="cards-container">

<div class="card">
<div class="field_0">固定的复习时间，一天至少几次?以及分别是什么时候？<br>一天至少三次，分别是早起上厕所时候，吃完午饭之后午休之前，以及晚上睡前。</div>
<div class="separator"></div>
<div class="field_1"><ol><li>清晨：利用<b><span style="color: rgb(255, 85, 0);">早晨起床后【在上厕所的时候】</span></b>的时间，大脑较为清醒，适合进行第一次复习</li><li>午间：在<b><span style="color: rgb(255, 85, 0);">午餐后、午休前的空档</span></b>，是进行知识巩固的理想时机</li><li>晚上：<b><span style="color: rgb(255, 85, 0);">睡前</span></b>进行最后一次复习，有助于记忆的长期保持</li></ol></div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，分别是利用了什么工具？</div>
<div class="separator"></div>
<div class="field_1"><ol><li>Anki闪卡系统，</li><li>Edge浏览器，</li><li>纸和笔来绘制思维导图。</li></ol><br></div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，第一阶段：主动记忆，使用了什么工具以及这个策略的核心理念是什么？</div>
<div class="separator"></div>
<div class="field_1">Anki闪卡系统<br>间隔重复学习 以及 主动回忆。</div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，第二阶段：听觉强化，使用了什么工具以及这个策略的核心理念是什么？</div>
<div class="separator"></div>
<div class="field_1">Edge浏览器的朗读功能，<br>在听取过程中训练预测能力，积极思考下一句内容。</div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，第三阶段：知识输出，使用了什么工具以及这个策略的核心理念是什么？</div>
<div class="separator"></div>
<div class="field_1">纸和笔，<br>在<span style="color: rgb(255, 85, 0);"><b>不依赖任何参考资料</b></span>的情况下，将脑中所学知识通过<b><span style="color: rgb(255, 85, 0);">思维导图的形式可视化</span></b></div>
</div>
<div class="card">
<div class="field_0">每天早晨上厕所时，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">快速<b><span style="color: rgb(255, 85, 0);">浏览昨天晚上</span></b>通过Edge浏览器朗读功能来复习的内容。</div>
</div>
<div class="card">
<div class="field_0">每天早晨上完厕所后，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">不参考资料的情况下，进行思维导图的绘制。</div>
</div>
<div class="card">
<div class="field_0">每天晚上睡前，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">利用<span style="color: rgb(255, 85, 0);"><b>Edge</b></span>浏览器的<span style="color: rgb(255, 85, 0);"><b>朗读</b></span>功能，将已复习过的笔记<span style="color: rgb(255, 85, 0);"><b>转化为音频</b></span>。<br>在听的过程中，<b><span style="color: rgb(255, 85, 0);">积极思考</span></b>下一句内容。</div>
</div>
<div class="card">
<div class="field_0">每天午休前，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">跟睡前的复习活动一样，<br>利用<span style="color: rgb(255, 85, 0);"><b>Edge</b></span>浏览器的<span style="color: rgb(255, 85, 0);"><b>朗读</b></span>功能，将已复习过的笔记<span style="color: rgb(255, 85, 0);"><b>转化为音频</b></span>。<br>在听的过程中，<b><span style="color: rgb(255, 85, 0);">积极思考</span></b>下一句内容。</div>
</div>
<div class="card">
<div class="field_0">每天午休醒来后，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">不参考资料的情况下，进行思维导图的绘制。</div>
</div>

<div class="card">
<div class="field_0">pred_sub_heads == 1 ：生成一个什么类型张量，标记什么？</div>
<div class="separator"></div>
<div class="field_1">布尔张量，<b><span style="color: rgb(255, 85, 0);">标记/筛选</span></b>哪些位置为实体头（值为 1）。</div>
</div>
<div class="card">
<div class="field_0"><br>heads = torch.arange(0, len(pred_sub_heads), device='cpu')[pred_sub_heads == 1]&nbsp;<br>对于 pred_sub_heads = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0]，heads&nbsp;的结果是什么？</div>
<div class="separator"></div>
<div class="field_1">heads = tensor([0, 6])</div>
</div>
<div class="card">
<div class="field_0">for head, tail in zip(<b><span style="color: rgb(255, 85, 0);">heads, tails</span></b>):<br>&nbsp;&nbsp;&nbsp; if tail &gt;= head:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subs.append((head.item(), tail.item()))<br><br>对于我们的例子，heads = [0, 6]，tails = [8, 9]，所以配对结果是什么？</div>
<div class="separator"></div>
<div class="field_1">(0, 8)<br>(6, 9)</div>
</div>
<div class="card">
<div class="field_0">heads = torch.arange(0, len(pred_sub_heads), device='cpu')[pred_sub_heads == 1]<br>代码执行的两个阶段是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>生成<b><span style="color: rgb(255, 85, 0);">位置索引</span></b> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]，</li><li>pred_sub_heads == 1 得到<span style="color: rgb(255, 85, 0);"><b>布尔张量</b></span>来 <span style="color: rgb(255, 85, 0);"><b>筛选</b></span>出 的位置索引，得到 <b><span style="color: rgb(255, 85, 0);">heads </span></b>。</li></ul></div>
</div>
<div class="card">
<div class="field_0">for head, tail in zip(heads, tails):<br>这个代码的含义是什么？</div>
<div class="separator"></div>
<div class="field_1">将 heads 和 tails 按顺序配对，遍历每一对 (head, tail)。</div>
</div>
<div class="card">
<div class="field_0">对于 heads = [0, 6] 和 tails = [8, 9]，将 heads 和 tails 按顺序配对，生成迭代器。<br>subs 包含所有有效的 (head, tail) 对，即尾索引不小于头索引的实体位置对。<br>【代码】</div>
<div class="separator"></div>
<div class="field_1">for head, tail in zip(<b><span style="color: rgb(255, 85, 0);">heads, tails</span></b>):<br>&nbsp;&nbsp;&nbsp; if tail &gt;= head:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(255, 85, 0);"><b>subs</b></span>.append((head.item(), tail.item()))</div>
</div>
<div class="card">
<div class="field_0">zip(heads, tails) 会将 heads 和 tails 按顺序配对，直到其中一个序列耗尽。这意味着什么？</div>
<div class="separator"></div>
<div class="field_1">如果 heads 和 tails 的数量不相同，多余的头或尾将被忽略。</div>
</div>
<div class="card">
<div class="field_0">zip(heads, tails) 会将 heads 和 tails 按顺序配对，如果 heads 和 tails 的数量不相同，会有什么结果？【多出来的那部分会被怎么样？】</div>
<div class="separator"></div>
<div class="field_1">多余的头或尾将被忽略。</div>
</div>
<div class="card">
<div class="field_0">zip(heads, tails) 会将 heads 和 tails 怎么处理？</div>
<div class="separator"></div>
<div class="field_1">按顺序配对。按顺序对应元素打包配对。</div>
</div>
<div class="card">
<div class="field_0">extract_sub 这个函数传入的两个参数名称是什么以及他们的格式是什么？</div>
<div class="separator"></div>
<div class="field_1">pred_sub_heads, pred_sub_tails，<br>格式都是 类似于下面这样的0,1 的二值一维张量。<br>[1, 0, 0, 0, 0, 0, 1, 0, 0, 0]</div>
</div>
<div class="card">
<div class="field_0">extract_sub 这个函数输出的变量的名称是什么以及他的格式是什么？</div>
<div class="separator"></div>
<div class="field_1">subs，<br>类似于[(0, 8), (6, 9)]，包含多个二元元组的列表。</div>
</div>
<div class="card">
<div class="field_0">当前实现中，zip(heads, tails) 为什么会导致多余的头或尾未被处理。【因为这个函数会截断到哪里？】</div>
<div class="separator"></div>
<div class="field_1">因为zip会截断到较短的序列长度。</div>
</div>
<div class="card">
<div class="field_0">defaultdict(list) 这行代码的两个主要特点。分别是什么？</div>
<div class="separator"></div>
<div class="field_1">当访问不存在的键的时候不会报错KeyError，而是自动创建一个默认值，<br>这个默认值呢是由list默认工厂函数创建的。<br><br><div><ul><li>defaultdict 允许在访问<b><span style="color: rgb(255, 85, 0);">不存在的键</span></b>时，<span style="color: rgb(255, 85, 0);"><b>自动为该键创建一个默认值</b></span>，进而避免存在性检查。</li><li>list 则是指定创建的<b><span style="color: rgb(255, 85, 0);">默认值</span></b>，是一个空的列表。</li></ul></div><div><div></div></div><div></div></div>
</div>
<div class="card">
<div class="field_0">在普通的 Python 字典（dict）中，如果您尝试访问一个不存在的键，会有什么结果？</div>
<div class="separator"></div>
<div class="field_1">会报错，引发 KeyError 异常。</div>
</div>
<div class="card">
<div class="field_0">defaultdict&nbsp; 在访问不存在的键时，不会引发 哪个错误，而是会根据提供的什么为该键生成一个什么？</div>
<div class="separator"></div>
<div class="field_1">KeyError错误，根据默认工厂函数（在您的例子中是 list），生成默认值。</div>
</div>
<div class="card">
<div class="field_0">defaultdict(list) 代码里面，list 被用作什么函数？</div>
<div class="separator"></div>
<div class="field_1">默认工厂函数。</div>
</div>
<div class="card">
<div class="field_0">defaultdict(list) 代码里面，<br>什么时候，defaultdict 会自动调用 list() 来为该键创建一个什么？</div>
<div class="separator"></div>
<div class="field_1">当您<span style="color: rgb(255, 85, 0);"><b>访问一个不存在的键</b></span>时，defaultdict 会自动调用 list() 来为该键创建一个<span style="color: rgb(255, 85, 0);"><b>默认值</b></span>，即一个<b><span style="color: rgb(255, 85, 0);">空列表 []</span></b>。</div>
</div>
<div class="card">
<div class="field_0">words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']<br>统计 words&nbsp;里面各个元素的频率，生成{'apple': 3, 'banana': 2, 'orange': 1} 这样的结构word_count为名字【代码】</div>
<div class="separator"></div>
<div class="field_1">word_count = <span style="color: rgb(255, 85, 0);"><b>defaultdict(int)</b></span><br>words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']<br><br>for word in words:<br>&nbsp;&nbsp;&nbsp; word_count[<span style="color: rgb(255, 85, 0);"><b>word</b></span>] <b><span style="color: rgb(255, 85, 0);">+= 1</span></b></div>
</div>
<div class="card">
<div class="field_0">defaultdict(xxx) 代码里面，xxx是默认工厂函数，常见的默认工厂函数可以是 list，他的作用是什么？【为每个键维护一个什么数据？】</div>
<div class="separator"></div>
<div class="field_1">list：适用于需要为<b><span style="color: rgb(255, 85, 0);">每个键维护一个列表</span></b>的场景（如<span style="color: rgb(255, 85, 0);"><b>分组数据</b></span>）。<br><br></div>
</div>
<div class="card">
<div class="field_0">defaultdict(xxx) 代码里面，xxx是默认工厂函数，常见的默认工厂函数可以是 dict，他的作用是什么？</div>
<div class="separator"></div>
<div class="field_1">dict：适用于<b><span style="color: rgb(255, 85, 0);">嵌套字典</span></b>的场景。</div>
</div>
<div class="card">
<div class="field_0">defaultdict(xxx) 代码里面，xxx是默认工厂函数，常见的默认工厂函数可以是 set，他的作用是什么？【每个键维护一个什么，避免什么情况？】</div>
<div class="separator"></div>
<div class="field_1">set：适用于需要为<span style="color: rgb(255, 85, 0);"><b>每个键维护一个集合</b></span>的场景，<b><span style="color: rgb(255, 85, 0);">避免重复元素</span></b>。<br></div>
</div>
<div class="card">
<div class="field_0">defaultdict(xxx) 代码里面，xxx是默认工厂函数，常见的默认工厂函数可以是 int 或 float，他的作用分别是什么？【分别的适用场景是什么？】</div>
<div class="separator"></div>
<div class="field_1">int 或 float：适用于<span style="color: rgb(255, 85, 0);"><b>计数</b></span>或<span style="color: rgb(255, 85, 0);"><b>累加求和</b></span>操作。</div>
</div>
<div class="card">
<div class="field_0">defaultdict(xxx) 代码里面，xxx是什么？用来干什么？</div>
<div class="separator"></div>
<div class="field_1">默认工厂函数.用来创建键的默认值。</div>
</div>
<div class="card">
<div class="field_0"># 假设我们有以下关系数据（主体实体, 关系）<br>relations = [<br>&nbsp;&nbsp;&nbsp; ('Alice', 'likes'),<br>&nbsp;&nbsp;&nbsp; ('Bob', 'dislikes'),<br>&nbsp;&nbsp;&nbsp; ('Alice', 'hates'),<br>&nbsp;&nbsp;&nbsp; ('Charlie', 'likes'),<br>&nbsp;&nbsp;&nbsp; ('Bob', 'likes'),<br>&nbsp;&nbsp;&nbsp; ('Alice', 'adores')<br>]<br>根据这个relations&nbsp;关系数据来构建s2ro_map&nbsp;【代码】</div>
<div class="separator"></div>
<div class="field_1"># 初始化 defaultdict<br>s2ro_map = defaultdict(list)<br><br># 构建映射<br>for subject, predicate in relations:<br>&nbsp;&nbsp;&nbsp; s2ro_map[subject].append(predicate)<br><br># 打印结果<br>for subject, rels in s2ro_map.items():<br>&nbsp;&nbsp;&nbsp; print(f"{subject}: {rels}")<br><br>Alice: ['likes', 'hates', 'adores']<br>Bob: ['dislikes', 'likes']<br>Charlie: ['likes']</div>
</div>
<div class="card">
<div class="field_0">Tokenizer&nbsp;主要 输入参数是什么？【7个】</div>
<div class="separator"></div>
<div class="field_1">text，max_length，padding，truncation，add_special_tokens，return_tensors，return_attention_mask。</div>
</div>
<div class="card">
<div class="field_0">Tokenizer&nbsp;主要 输出参数是什么？【3个】</div>
<div class="separator"></div>
<div class="field_1">input_ids，attention_mask，token_type_ids。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输入参数是什么？</div>
<div class="separator"></div>
<div class="field_1">input_ids，attention_mask，token_type_ids。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输入参数 一般是谁处理之后的结果？</div>
<div class="separator"></div>
<div class="field_1">Tokenizer处理之后的结果。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输入参数token_type_ids，在单句任务中 以及 在句子对任务中分别的值是什么样的？</div>
<div class="separator"></div>
<div class="field_1">在单句任务中通常全为0；在句子对任务中，使用0,1 来用于区分两个句子。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输出参数是什么？【参数名】</div>
<div class="separator"></div>
<div class="field_1">last_hidden_state，pooler_output。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输出参数是last_hidden_state 的字面含义是什么? 表示什么向量？以及形状是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>last_hidden_state（<b><span style="color: rgb(255, 85, 0);">最后一层的隐藏状态</span></b>），<br>表示的是词向量。<br>形状为 [batch_size, sequence_length, hidden_size]。</li></ul></div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输出参数是pooler_output 的含义以及形状是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>pooler_output（<span style="color: rgb(255, 85, 0);"><b>池化后的输出</b></span>）：形状为 [<b><span style="color: rgb(255, 85, 0);">batch_size, hidden_size</span></b>]。&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输出参数是pooler_output ，通常是 哪个token的向量经过哪两个步骤之后的结果，用作表示什么？</div>
<div class="separator"></div>
<div class="field_1">&nbsp;[CLS] token 的向量，一个全连接层和 Tanh 激活函数后，用于句子级别的表示（即句向量）。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输出参数是last_hidden_state，包含什么信息？</div>
<div class="separator"></div>
<div class="field_1">每个token的词向量。<br>每个 token 的上下文相关向量表示（即词向量）。</div>
</div>
<div class="card">
<div class="field_0">从原始文本输入，到BERT 模型的输出，流程是什么？【原始文本输入之后，经过谁的处理，生成哪三个数据？这三个数据输入到哪里？最终又输出什么？】</div>
<div class="separator"></div>
<div class="field_1"><li><strong>原始文本输入</strong></li><li><strong>Tokenizer 处理</strong></li><li><strong>生成输入格式（<code>input_ids</code>、<code>attention_mask</code>、<code>token_type_ids</code>）</strong></li><li><strong>输入 BERT 模型</strong></li><li><strong>获取输出（<code>last_hidden_state</code>、<code>pooler_output</code>）</strong></li></div>
</div>
<div class="card">
<div class="field_0">初始化 Tokenizer 和 BERT 模型【示例代码】</div>
<div class="separator"></div>
<div class="field_1"><ol><li>tokenizer = <b><span style="color: rgb(255, 85, 0);">BertTokenizer</span></b>.from_pretrained('bert-base-chinese')
</li><li>model = <b><span style="color: rgb(255, 85, 0);">BertModel</span></b>.from_pretrained('bert-base-chinese')&nbsp;</li></ol></div>
</div>
<div class="card">
<div class="field_0">Tokenizer 的输出结果包含Attention Masks，他指的是什么意思？<br></div>
<div class="separator"></div>
<div class="field_1">标记那些是填充项，哪些是真实token。<br>（指示哪些token是有效的，哪些是填充的）</div>
</div>
<div class="card">
<div class="field_0">Tokenizer 的输出结果输入到bert模型之后，经过哪两个层？</div>
<div class="separator"></div>
<div class="field_1">嵌入层（Embedding Layer）以及&nbsp;Transformer编码器层。</div>
</div>
<div class="card">
<div class="field_0">Tokenizer 的输出结果输入到bert模型内部，首先来到嵌入层（Embedding Layer）阶段，经历了什么？【转换成什么嵌入？加入什么嵌入和什么嵌入，最终生成了什么？】</div>
<div class="separator"></div>
<div class="field_1"><ul><li>将input_ids转换为<b><span style="color: rgb(255, 85, 0);">词嵌入</span></b>（word embeddings）。<br></li><li>加入<span style="color: rgb(255, 85, 0);"><b>位置嵌入</b></span>（positional embeddings）和<b><span style="color: rgb(255, 85, 0);">Token类型嵌入</span></b>（token type embeddings）。<br></li><li>生成<b><span style="color: rgb(255, 85, 0);">输入嵌入矩阵</span></b>，形状为 [batch_size, sequence_length, hidden_size]。</li></ul></div>
</div>
<div class="card">
<div class="field_0">Tokenizer 的输出结果输入到模型之后，来到bert模型里面的Transformer编码器，处理什么数据，生成什么数据。</div>
<div class="separator"></div>
<div class="field_1">处理输入嵌入，生成隐藏状态（hidden states）。</div>
</div>
<div class="card">
<div class="field_0">假设hidden_size为768，sequence_length为8（包括特殊标记），batch_size为1。<br>last_hidden_states 和 pooler_output 的形状分别是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>last_hidden_states 的形状为 [1, 8, 768]。
</li><li>pooler_output 的形状为 [1, 768]。
</li></ul> <br></div>
</div>
<div class="card">
<div class="field_0">Bert 模型的输出是两个类型的向量，分别是什么？然后各自的参数的名称是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>词向量（Token Embeddings），对应last_hidden_states。</li><li>句向量（Sentence Embedding），对于pooler_output。</li></ul></div>
</div>
<div class="card">
<div class="field_0">Bert 模型的输出是包含pooler_output，它对应的是<code>哪个</code> token对应的向量，表示什么？</div>
<div class="separator"></div>
<div class="field_1">[CLS] token对应的向量，表示整个句子的语义。</div>
</div>
<div class="card">
<div class="field_0">Bert 模型的输出里面，谁是 词向量、谁是&nbsp;句向量?</div>
<div class="separator"></div>
<div class="field_1">last_hidden_states（词向量）、pooler_output（句向量）</div>
</div>
<div class="card">
<div class="field_0">Tokenizer 负责将什么转换为谁可接受的格式，Tokenizer包括哪两个处理阶段？<br></div>
<div class="separator"></div>
<div class="field_1">原始文本，BERT模型，分词和编码。<br></div>
</div>
<div class="card">
<div class="field_0">BERT 模型 接受编码后的输入，生成谁的向量表示和谁的向量表示。</div>
<div class="separator"></div>
<div class="field_1">每个token，整个句子。</div>
</div>
<div class="card">
<div class="field_0"><div>Pipeline 方法的数据格式是什么？每行内容是什么？</div></div>
<div class="separator"></div>
<div class="field_1"><ul><li>一个文本对应多行。</li><li>每一行对应一个<span style="color: rgb(255, 85, 0);"><b>关系三元组</b></span>（主体、客体、关系）以及<span style="color: rgb(255, 85, 0);"><b>原始文本</b></span>。也就是<b><span style="color: rgb(255, 85, 0);">主体、客体、关系、文本的四列划分。</span></b></li></ul>似水流年 闫肃 作词 似水流年，由著名作词家闫肃作词，著名音乐人许晓杰作曲，张烨演唱&nbsp;<br></div>
</div>
<div class="card">
<div class="field_0"><div>Joint 方法的原始数据里面，每一行的格式是什么？每行内容是什么？</div></div>
<div class="separator"></div>
<div class="field_1"><ul><li>每个文本对应一行。</li><li>每一行是一个 JSON 对象，包含文本及其所有关系三元组，text以及spo_list这两个键。</li></ul>{<br>&nbsp; "text": "古建桥，汉族，现任四川省彭州市委副书记",<br>&nbsp; "spo_list": [<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "predicate": "民族",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "object_type": "文本",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "subject_type": "人物",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "object": "汉族",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "subject": "古建桥"<br>&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "predicate": "职位",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "object_type": "职位",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "subject_type": "人物",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "object": "四川省彭州市委副书记",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "subject": "古建桥"<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; ]<br>}<br></div>
</div>
<div class="card">
<div class="field_0"><div>Joint 方法 和 Pipeline方法每行的格式是什么？</div></div>
<div class="separator"></div>
<div class="field_1"><ul><li>对于join方法它的每一行是字典，包含两个键分别是text以及spo_list，</li><li>对于pipeline方法，它的每行是四列，每一列分别是主体，客体，关系类型，原始文本&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="field_0">Pipeline 方法和joint方法他们的流程上的区别是什么？</div>
<div class="separator"></div>
<div class="field_1">Pipeline&nbsp;方法的话是将实体识别和关系抽取作为两个独立的任务先后执行，<br>Joint&nbsp;方法将 实体识别和关系抽取 这两个任务同时进行，这样做的好处是避免了管道pipeline方法里面的错误传播。</div>
</div>
<div class="card">
<div class="field_0">CasRel 是否集成在主流库中（如pip、conda、PyTorch、Hugging Face等）？</div>
<div class="separator"></div>
<div class="field_1">没有。</div>
</div>
<div class="card">
<div class="field_0">CasRel 是联合抽取（Joint Extraction）模型还是管道（Pipeline）模型？<div><br></div></div>
<div class="separator"></div>
<div class="field_1">CasRel 属于联合抽取（Joint Extraction）模型。</div>
</div>
<div class="card">
<div class="field_0"><div>CasRel是基于哪个模型，然后在这个模型基础上添加了几个线性层，分别用于什么？<br></div></div>
<div class="separator"></div>
<div class="field_1">基于Bert模型，添加了4个线性层，分别用于预测主体的头部和尾部，以及客体的头部和尾部。</div>
</div>
<div class="card">
<div class="field_0"><div>CasRel采用级联的方式，这个方式是什么意思？<br></div></div>
<div class="separator"></div>
<div class="field_1">即先识别主实体，再基于主实体识别客实体及其关系。</div>
</div>
<div class="card">
<div class="field_0">“要事为先”强调在一天的学习计划中，将什么任务安排在认知资源怎么样的时段，通常是早晨。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">最重要和最具挑战性的任务，最为充沛的时段。</div>
</div>
<div class="card">
<div class="field_0">每天早晨起床后，首先进行最重要的学习任务，比如哪三种？</div>
<div class="separator"></div>
<div class="field_1">新知识的学习、复杂问题的解决或深度阅读。</div>
</div>
<div class="card">
<div class="field_0">认知峰值理论：研究表明，人的认知性能在一天中的什么时候达到峰值？</div>
<div class="separator"></div>
<div class="field_1">早上。</div>
</div>
<div class="card">
<div class="field_0">“分散学习”指的是将什么分散到什么进行，而不是什么？</div>
<div class="separator"></div>
<div class="field_1">学习任务，多个时间段，一次性集中学习。</div>
</div>
<div class="card">
<div class="field_0">“分层学习”强调逐步构建知识体系，先掌握什么，再逐步深入什么部分？</div>
<div class="separator"></div>
<div class="field_1">基础部分，复杂内容。</div>
</div>
<div class="card">
<div class="field_0">在学习过程中，遇到不理解或难以掌握的部分怎么办？</div>
<div class="separator"></div>
<div class="field_1">标记不理解或难以掌握的部分，准备在后续时间段进行重点攻克。</div>
</div>
<div class="card">
<div class="field_0">多轮学习：每次学习时，先怎么样，再怎么样？</div>
<div class="separator"></div>
<div class="field_1">先复习前一轮的内容，再学习新的部分，逐步深化理解。</div>
</div>
<div class="card">
<div class="field_0">交叉学习”指的是在学习过程中，怎么样？</div>
<div class="separator"></div>
<div class="field_1">穿插不同的学习内容或科目。</div>
</div>
<div class="card">
<div class="field_0">交叉学习”指的是在学习过程中，穿插不同的学习内容或科目。这种方法可以 避免 什么？</div>
<div class="separator"></div>
<div class="field_1">避免学习单一主题带来的疲劳和认知干扰。</div>
</div>
<div class="card">
<div class="field_0">交叉学习的策略的时候，制定学习循环，内容是什么？</div>
<div class="separator"></div>
<div class="field_1">将不同的学习内容有序地安排在一天的不同时间段，如上午学习数学，下午学习语言，晚上进行科学阅读。</div>
</div>
<div class="card">
<div class="field_0">及时复习能够在记忆怎样时进行巩固，增强记忆痕迹。</div>
<div class="separator"></div>
<div class="field_1">尚未完全消退时。</div>
</div>
<div class="card">
<div class="field_0">根据遗忘曲线理论，信息在学习后的多久内遗忘速度最快。</div>
<div class="separator"></div>
<div class="field_1">最初几天。</div>
</div>
<div class="card">
<div class="field_0">精细复述 ，指的是在学习过程中，怎么样。</div>
<div class="separator"></div>
<div class="field_1">将所学内容用自己的语言重新表达。</div>
</div>
<div class="card">
<div class="field_0">精细复述 ，这种方法有助于减少信息的什么，压缩和整理信息，促进什么样的理解和记忆。</div>
<div class="separator"></div>
<div class="field_1">混乱，深层次。</div>
</div>
<div class="card">
<div class="field_0">用自己的语言表达，为什么可以减少信息的冗余和混乱？</div>
<div class="separator"></div>
<div class="field_1">因为需要将信息压缩和整理、</div>
</div>
<div class="card">
<div class="field_0">根据哪两个原则，合理安排一天的学习任务，确保高效利用大脑的认知资源。</div>
<div class="separator"></div>
<div class="field_1">“要事为先”和“分散学习”。</div>
</div>
<div class="card">
<div class="field_0">在不同的学习阶段，结合哪两个学习原则，逐步深化知识，同时保持学习的多样性和新鲜感。</div>
<div class="separator"></div>
<div class="field_1">分层学习和交叉学习。</div>
</div>
<div class="card">
<div class="field_0">在不同的学习阶段，结合分层学习和交叉学习，可以怎样的同时，保持什么？</div>
<div class="separator"></div>
<div class="field_1">逐步深化知识，同时保持学习的多样性和新鲜感。</div>
</div>
<div class="card">
<div class="field_0">根据“要事为先”和“分散学习”的原则，合理安排什么，确保高效利用什么？</div>
<div class="separator"></div>
<div class="field_1">安排一天的学习任务，利用大脑的认知资源。</div>
</div>
<div class="card">
<div class="field_0">在每次学习后，立即进行哪两个学习策略，巩固记忆，深化理解。</div>
<div class="separator"></div>
<div class="field_1">及时复习和精细复述。</div>
</div>
<div class="card">
<div class="field_0"><span style="white-space: pre-wrap;">要事为先 这</span>个学习策略，如何理解？</div>
<div class="separator"></div>
<div class="field_1"><pre><code><b><span style="color: rgb(255, 85, 0);">早上优先</span></b>学习，趁着认知资源还很充沛、干扰还很少、疲劳还没显现；<br></code></pre></div>
</div>
<div class="card">
<div class="field_0"><span style="white-space: pre-wrap;">分散学习</span><span style="white-space: pre-wrap;"> 这</span>个学习策略，如何理解？</div>
<div class="separator"></div>
<div class="field_1"><pre><code>不要一天学很多，每天<span style="color: rgb(255, 85, 0);"><b>学一点</b></span>，然后带着<b><span style="color: rgb(255, 85, 0);">复习笔记</span></b>，到了下次就能熟练调用新知了，也就很少会遇到困难了；</code></pre></div>
</div>
<div class="card">
<div class="field_0"><span style="white-space: pre-wrap;">分层学习</span><span style="white-space: pre-wrap;"> 这</span>个学习策略，如何理解？</div>
<div class="separator"></div>
<div class="field_1"><pre><code><b><span style="color: rgb(255, 85, 0);">先学会的</span></b>，<b><span style="color: rgb(255, 85, 0);">不会的部分做好标记</span></b>留到下一轮再学，随着下一轮时新知的更新，之前不会的往往就会了；<br></code></pre></div>
</div>
<div class="card">
<div class="field_0"><span style="white-space: pre-wrap;">交叉学习</span><span style="white-space: pre-wrap;"> 这</span>个学习策略，如何理解？</div>
<div class="separator"></div>
<div class="field_1"><pre><code>如果你觉得分散学习、分层学习剩下的时间浪费了可惜，也可以换着<b><span style="color: rgb(255, 85, 0);">穿插学习其他内容</span></b>，这期间正好给新知留出巩固的时间；<br></code></pre></div>
</div>
<div class="card">
<div class="field_0"><span style="white-space: pre-wrap;">及时复习</span><span style="white-space: pre-wrap;"> 这</span>个学习策略，如何理解？</div>
<div class="separator"></div>
<div class="field_1"><pre><code><b><span style="color: rgb(255, 85, 0);">学完一节就复习</span></b>一节，理清头绪，巩固新知，不要等一章学完已经忘了许多、陷入混乱了再复习；</code></pre></div>
</div>
<div class="card">
<div class="field_0"><span style="white-space: pre-wrap;">精细复述</span><span style="white-space: pre-wrap;"> 这</span>个学习策略，如何理解？</div>
<div class="separator"></div>
<div class="field_1"><pre><code>也叫深加工，或者叫<b><span style="color: rgb(255, 85, 0);">用自己的话</span></b>，这样可以减少混乱、压缩信息、整理信息，避免一股脑儿全盘照搬，导致认知过载、学不进去了</code></pre></div>
</div>
<div class="card">
<div class="field_0">“要事为先”、“分散学习”、“分层学习”、“交叉学习”、“及时复习”和“精细复述”<br><span style="white-space: pre-wrap;">对于上面这六个策略，
早上早起之后，9:00 之间的学习策略是什么？以及为什么？</span></div>
<div class="separator"></div>
<div class="field_1">1 “要事为先”、2 “分层学习”<br><ol><li><span style="color: rgb(255, 85, 0);"><b>早晨</b></span>精力充沛时优先处理具有<span style="color: rgb(255, 85, 0);"><b>挑战性</b></span>的学习内容。</li><li>当遇到<span style="color: rgb(255, 85, 0);"><b>难以推进的部分</b></span>时，及时<span style="color: rgb(255, 85, 0);"><b>标记并</b></span>适当<span style="color: rgb(255, 85, 0);"><b>暂停</b></span>。每次<span style="color: rgb(255, 85, 0);"><b>学习一小部分</b></span>，同时结合之前的<b><span style="color: rgb(255, 85, 0);">学习笔记进行复习</span></b>，以加深理解</li></ol></div>
</div>
<div class="card">
<div class="field_0">&nbsp;“分散学习”、“分层学习”、“交叉学习”&nbsp;<br><span style="white-space: pre-wrap;">对于上面这三个策略，区别的要点是什么? </span></div>
<div class="separator"></div>
<div class="field_1"><ul><li>分散学习：将学习内容适当分散，<span style="color: rgb(255, 85, 0);"><b>不必一天贪多</b></span>，而是把内容合理分配到<b><span style="color: rgb(255, 85, 0);">一周的不同时间段</span></b>内进行学习。</li><li>分层学习：采用循序渐进的方式，<span style="color: rgb(255, 85, 0);"><b>先掌握基础</b></span>内容，对于遇到的<span style="color: rgb(255, 85, 0);"><b>难点先做标记</b></span>，留待<span style="color: rgb(255, 85, 0);"><b>下一轮</b></span>学习。每轮学习都遵循"<b><span style="color: rgb(255, 85, 0);">学习-记录笔记-复习巩固</span></b>"这三个阶段的循环模式。</li><li>交叉学习：在学习过程中适当<b><span style="color: rgb(255, 85, 0);">穿插其他领域</span></b>的知识内容，避免单一学科带来的疲劳，同时培养多元化的知识结构。<br></li></ul></div>
</div>
<div class="card">
<div class="field_0"><span style="white-space: pre-wrap;">学习过程中，遇到难点学不动的时候，怎么办？策略是什么？【策略名称和策略内容】</span></div>
<div class="separator"></div>
<div class="field_1"><span style="white-space: pre-wrap;"><span style="color: rgb(255, 85, 0);"><b>分层学习的策略</b></span>，<span style="color: rgb(255, 85, 0);"><b>最小学习循环</b></span>为单元，每一轮是 <span style="color: rgb(255, 85, 0);"><b>学习-笔记-复习</b></span> 的三个阶段的循环。
<ol><li>在<span style="color: rgb(255, 85, 0);"><b>每一轮</b></span>学习循环中，应先<span style="color: rgb(255, 85, 0);"><b>专注</b></span>于<span style="color: rgb(255, 85, 0);"><b>已掌握的内容</b></span>，将其整理成系统的<span style="color: rgb(255, 85, 0);"><b>学习笔记</b></span>，并通过<span style="color: rgb(255, 85, 0);"><b>复习</b></span>来巩固知识。</li><li>对于暂时<span style="color: rgb(255, 85, 0);"><b>难以理解</b></span>的知识点，可以先做<span style="color: rgb(255, 85, 0);"><b>标记</b></span>，留待<b><span style="color: rgb(255, 85, 0);">下一轮</span></b>学习循环时再重点攻克。</li></ol></span><span style="white-space: pre-wrap;"></span></div>
</div>
<div class="card">
<div class="field_0">分层学习 的核心是什么？</div>
<div class="separator"></div>
<div class="field_1">按照<span style="color: rgb(255, 85, 0);"><b>轮次循环</b></span>进行学习，<span style="color: rgb(255, 85, 0);"><b>第一轮</b></span>学习<span style="color: rgb(255, 85, 0);"><b>直至遇到难点</b></span>。<br>分层学习是指先学习<span style="color: rgb(255, 85, 0);"><b>已掌握</b></span>的内容，遇到不会的<span style="color: rgb(255, 85, 0);"><b>难点</b></span>做好<span style="color: rgb(255, 85, 0);"><b>标记</b></span>，<span style="color: rgb(255, 85, 0);"><b>下一轮</b></span>再进行学习。<br>每一轮都遵循“<b><span style="color: rgb(255, 85, 0);">学习 - 笔记 - 复习</span></b>”这三个阶段循环进行。</div>
</div>
<div class="card">
<div class="field_0">分层学习的核心理念在于什么？</div>
<div class="separator"></div>
<div class="field_1">合理区分基础内容和难点内容。&nbsp;</div>
</div>
<div class="card">
<div class="field_0">分层学习的核心理念在于合理区分基础内容和难点内容。在每一轮学习过程中，怎么做？</div>
<div class="separator"></div>
<div class="field_1">我们只需专注于<span style="color: rgb(255, 85, 0);"><b>复杂内容的一小部分</b></span>，并通过<b><span style="color: rgb(255, 85, 0);">回顾和复习</span></b>已掌握的<b><span style="color: rgb(255, 85, 0);">基础</span></b>知识，来逐步突破难点、加深理解。&nbsp;</div>
</div>
<div class="card">
<div class="field_0">联合抽取方法分类为哪两种？</div>
<div class="separator"></div>
<div class="field_1"><ul><li><b><span style="color: rgb(255, 85, 0);">参数共享</span></b>的联合模型，级联的方式</li><li><b><span style="color: rgb(255, 85, 0);">联合解码</span></b>的联合模型。</li></ul></div>
</div>
<div class="card">
<div class="field_0">联合抽取方法 里面的参数共享的联合模型，有什么特点？【编码的层面以及损失函数的层面】</div>
<div class="separator"></div>
<div class="field_1">不同的任务共享同一个bert编码器层。不同任务有各自的损失函数，相加得到总的损失函数，利用总的损失函数来进行参数更新。<br><br>主体、客体和关系的抽取任务在同一模型中进行，通常共享底层的表示（如 BERT 的隐藏层）。<br>每个任务有独立的损失函数，整个模型的总损失是各个任务损失的加权和。</div>
</div>
<div class="card">
<div class="field_0">联合抽取方法 里面的联合解码的联合模型，联合解码有什么特点？输出结果有什么特点？</div>
<div class="separator"></div>
<div class="field_1">实体识别和关于抽取这两个任务，它们的解码过程是统一的，同时进行的。以及这两个任务的输出的结果是在同一层次上完成输出直接形成完整的三元组。<br><br>主体、客体和关系的抽取任务通过一个统一的解码过程同时完成，所有任务的抽取在同一时间步或同一层次上进行，输出直接形成完整的 SPO（三元组）结构。</div>
</div>
<div class="card">
<div class="field_0">联合抽取方法分类为两种，参数共享的联合模型 以及&nbsp;联合解码的联合模型。CasRel&nbsp; 属于哪一种？</div>
<div class="separator"></div>
<div class="field_1">CasRel&nbsp; 属于&nbsp; 参数共享的联合模型。</div>
</div>
<div class="card">
<div class="field_0">CasRel 使用同一个 什么来生成输入文本的上下文表示，这为实体识别和关系抽取提供了什么？</div>
<div class="separator"></div>
<div class="field_1">&nbsp;BERT 编码器，共享的语义信息。</div>
</div>
<div class="card">
<div class="field_0">CasRel 里面 主体和客体的识别以及关系的预测都基于同一个什么，这意味着这些任务怎么样 底层的特征表示。</div>
<div class="separator"></div>
<div class="field_1">同一个 BERT 输出的隐藏状态，共享底层的特征表示。</div>
</div>
<div class="card">
<div class="field_0">CasRel 在预测过程中采用了级联的方式，这里如何理解“级联”？</div>
<div class="separator"></div>
<div class="field_1">级联代表着预测的顺序关系。先识别主体，再基于主体识别客体及关系。</div>
</div>
<div class="card">
<div class="field_0">参数共享的联合模型的定义是什么？【他们共享什么，但有独立的什么？】</div>
<div class="separator"></div>
<div class="field_1">他们共享编码器，相同的语义表示，但是呢不同任务有独立的损失函数。<br><br>不同任务共享参数但有独立的任务目标。</div>
</div>
<div class="card">
<div class="field_0">CasRel 各个阶段是否有独立的损失函数？分别是哪些阶段？以及后续是如何处理的？</div>
<div class="separator"></div>
<div class="field_1">每个预测阶段（主体、客体、关系）都有独立的损失函数，<br>预测主体起止位置，客体起止位置以及对应关系类别。<br>整个模型的总损失是这些独立损失的加权和。</div>
</div>
<div class="card">
<div class="field_0">CasRel 是一个联合模型，又具有级联的特性。如何理解这里的“联合训练” 和 “ 级联预测” 呢？</div>
<div class="separator"></div>
<div class="field_1">联合训练指的是这两个任务，实体识别和关系收取这两个任务。训练过程中是联合的，也就是他们共享了编码器以及使用共同的损失函数。<br>级联预测表示在预测过程，也就是前沿传播过程中，他们存在先后关系，有先后顺序。<br><br><li><strong>联合训练</strong>：CasRel 的<span style="color: rgb(255, 85, 0);"><b>所有任务</b></span>在<span style="color: rgb(255, 85, 0);"><b>同一个训练</b></span>过程中进行<span style="color: rgb(255, 85, 0);"><b>优化</b></span>，实体识别和关系抽取<b><span style="color: rgb(255, 85, 0);">共享相同的编码器</span></b>和特征表示。</li><li><strong>级联预测</strong>：在预测过程中，CasRel 通过<span style="color: rgb(255, 85, 0);"><b>级联</b></span>步骤（先主体，再客体和关系）来提高抽取的准确性。<b><span style="color: rgb(255, 85, 0);">分阶段的预测</span></b>方式。</li></div>
</div>
<div class="card">
<div class="field_0">CasRel 是一个联合模型，如何理解“联合”的意思呢？</div>
<div class="separator"></div>
<div class="field_1">联合指的是多个任务一起。多个任务一起共享模型底层的参数以及一起被训练。<br><br><strong>联合训练</strong>：CasRel 的<span style="color: rgb(255, 85, 0);"><b>所有任务</b></span>在<span style="color: rgb(255, 85, 0);"><b>同一个训练</b></span>过程中进行<span style="color: rgb(255, 85, 0);"><b>优化</b></span>，实体识别和关系抽取<b><span style="color: rgb(255, 85, 0);">共享相同的编码器</span></b>和特征表示。</div>
</div>
<div class="card">
<div class="field_0">CasRel 模型 具有<strong>级联 的性质</strong>，如何理解“<strong>级联&nbsp;</strong>”的意思呢？</div>
<div class="separator"></div>
<div class="field_1"><strong>级联预测</strong>：在预测过程中，CasRel 通过<span style="color: rgb(255, 85, 0);"><b>级联</b></span>步骤（先主体，再客体和关系）来提高抽取的准确性。<b><span style="color: rgb(255, 85, 0);">分阶段的预测</span></b>方式。</div>
</div>
<div class="card">
<div class="field_0">CasRel 通过为每个任务设定 独立的什么，并将其怎么样来实现了多任务的联合训练。</div>
<div class="separator"></div>
<div class="field_1">为每个任务设定独立的损失函数，并将其综合到总损失中。</div>
</div>
<div class="card">
<div class="field_0">CasRel 是一个参数共享的联合模型，这里的“联合” 指的是 目前在哪个阶段？</div>
<div class="separator"></div>
<div class="field_1">模型最后参数被更新的阶段。<br><span style="color: rgb(255, 85, 0);"><b>训练</b></span>和<span style="color: rgb(255, 85, 0);"><b>优化</b></span>这两个阶段，<br>实体识别和关系抽取任务的联合训练和优化。</div>
</div>
<div class="card">
<div class="field_0">相比于管道模型，联合模型的核心在于哪两个方面？</div>
<div class="separator"></div>
<div class="field_1">任务间的参数共享和使用一个共同的总的损失函数。</div>
</div>
<div class="card">
<div class="field_0">CasRel 的级联特性指的是什么？【指的是哪个阶段？】</div>
<div class="separator"></div>
<div class="field_1">级联只是<b><span style="color: rgb(255, 85, 0);">预测顺序</span></b>上的选择。</div>
</div>
<div class="card">
<div class="field_0">CasRel 的名字来自哪里？从名字上可以看出什么功能？</div>
<div class="separator"></div>
<div class="field_1">&nbsp;<span style="color: rgb(255, 85, 0);"><b>Cascade </b></span>Binary Tagging for <b><span style="color: rgb(255, 85, 0);">Relation </span></b>Extraction with Label Dependencies，<br>级联的关系抽取模型。</div>
</div>
<div class="card">
<div class="field_0">&nbsp;<span style="color: rgb(255, 85, 0);"><b>Cascade&nbsp;</b></span>Binary Tagging for&nbsp;<b><span style="color: rgb(255, 85, 0);">Relation&nbsp;</span></b>Extraction<br>中文名称是什么？</div>
<div class="separator"></div>
<div class="field_1">级联的二进制标记方法来实现关系提取。</div>
</div>
<div class="card">
<div class="field_0">CasRel 在哪个模型的基础上添加了什么来进行不同任务的预测？</div>
<div class="separator"></div>
<div class="field_1">模型基于 <span style="color: rgb(255, 85, 0);"><b>BERT</b></span>，在其基础上添加了<b><span style="color: rgb(255, 85, 0);">多个线性层</span></b>来进行不同任务的预测。</div>
</div>
<div class="card">
<div class="field_0">联合模型（Joint Model） 字面意思是通常指的是什么？【在同一个框架下怎么样？】</div>
<div class="separator"></div>
<div class="field_1">联合模型（Joint Model） 通常指的是在<b><span style="color: rgb(255, 85, 0);">同一框架下同时处理多个相关任务</span></b>，使得这些任务之间可以相互影响和优化。</div>
</div>
<div class="card">
<div class="field_0">多个预测任务在同一模型中进行训练。这样的模型叫做什么模型？<br></div>
<div class="separator"></div>
<div class="field_1">联合模型（Joint Model）&nbsp;</div>
</div>
<div class="card">
<div class="field_0">CasRel 模型的工作流程里面，哪些层是并行的？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>主体起始位置预测层和主体结束位置预测层，这两个层是并行且独立，</li><li>然后客体起始位置预测层和客体结束位置预测层，这两个层是并行且独立。</li></ul></div>
</div>
<div class="card">
<div class="field_0">CasRel 模型 的英文名称包含Cascade Binary Tagging，意思是 级联二进制标记，级联 和 二进制标记 分别是什么意思？</div>
<div class="separator"></div>
<div class="field_1">级联表示两个阶段是有先后顺序的。二进制标记表示的是各个位置的预测，是一个2分类问题。<br><br><li><strong>级联（Cascade）</strong>：两个阶段是具有先后顺序。模型<span style="color: rgb(255, 85, 0);"><b>先识别主体</b></span>实体，然后基于已识别的主体实体，<span style="color: rgb(255, 85, 0);"><b>进一步识别客体</b></span>实体及其<b><span style="color: rgb(255, 85, 0);">关系</span></b>。</li><li><strong>二进制标记（Binary Tagging）</strong>：每个位置的预测变成一个二分类的问题。<span style="color: rgb(255, 85, 0);"><b>每个标注任务</b></span>被视为独立的<span style="color: rgb(255, 85, 0);"><b>二分类</b></span>问题，例如判断<b><span style="color: rgb(255, 85, 0);">某个位置是否为</span></b>实体的起始或结束位置。</li></div>
</div>
<div class="card">
<div class="field_0">CasRel 模型的级联二进制标记，英文名称是什么？</div>
<div class="separator"></div>
<div class="field_1">Cascade Binary Tagging。</div>
</div>
<div class="card">
<div class="field_0">CasRel 模型的级联二进制标记，意味着 实体或关系的识别被视为一个二分类问题，这是什么意思？【也就是判定特定位置是否是什么？】</div>
<div class="separator"></div>
<div class="field_1">即某个特定位置是否为实体的起始或结束位置。</div>
</div>
<div class="card">
<div class="field_0">若一个模型包含4个线性层，且这4个线性层并行同步运行，那么该模型究竟属于单层网络还是4层网络呢？以及为什么？</div>
<div class="separator"></div>
<div class="field_1">被视为一个<span style="color: rgb(255, 85, 0);"><b>单层</b></span>网络。因为数据只经过了<span style="color: rgb(255, 85, 0);"><b>一层</b></span>并行的<span style="color: rgb(255, 85, 0);"><b>线性变换</b></span>。因为层数反映的是数据在网络中<b><span style="color: rgb(255, 85, 0);">被逐层处理的深度</span></b>。</div>
</div>
<div class="card">
<div class="field_0">常见的并行结构是多头注意力机制（Multi-Head Attention），其中多个注意力头并行处理输入，然后将结果合并。内部有多个并行的计算单元。这种结构被认为是一个多个还是单个注意力层？</div>
<div class="separator"></div>
<div class="field_1">单一的注意力层。</div>
</div>
<div class="card">
<div class="field_0">模型包含4个线性层，这4个线性层是并行同步运行的。这意味着什么？【输入怎么样？每个层是什么操作？最终的结果怎么样？】</div>
<div class="separator"></div>
<div class="field_1"><li><strong>输入同时进入这4个线性层</strong>。</li><li><strong>每个线性层独立进行线性变换</strong>。</li><li><strong>最终将这4个输出合并</strong>，可能通过拼接、加和等方式。</li></div>
</div>
<div class="card">
<div class="field_0">dbms.security.auth_enabled=false 这一行配置项的作用是什么？</div>
<div class="separator"></div>
<div class="field_1">禁用 Neo4j 的身份验证。</div>
</div>
<div class="card">
<div class="field_0">在 Neo4j 中，默认启用身份验证，也就是什么时候需要提供用户名和密码。</div>
<div class="separator"></div>
<div class="field_1">即每次连接时。</div>
</div>
<div class="card">
<div class="field_0">dbms.security.auth_enabled=false 存在哪个文件中？</div>
<div class="separator"></div>
<div class="field_1">neo4j.conf。</div>
</div>
<div class="card">
<div class="field_0">dbms.security.auth_enabled=false 这个配置的好处是什么？</div>
<div class="separator"></div>
<div class="field_1">可以在没有输入用户名和密码的情况下连接到数据库。</div>
</div>
<div class="card">
<div class="field_0">7474 和&nbsp;7687，分别是哪个协议的端口？</div>
<div class="separator"></div>
<div class="field_1"><div>7474 是 Neo4j 的 HTTP 协议端口，而不是 Bolt 协议端口。Bolt 协议 默认使用的是 7687 端口。</div><div></div></div>
</div>
<div class="card">
<div class="field_0">python代码里面通过哪个库来连接 Neo4j？</div>
<div class="separator"></div>
<div class="field_1">py2neo 。</div>
</div>
<div class="card">
<div class="field_0">bolt://：这是 什么意思？</div>
<div class="separator"></div>
<div class="field_1">Neo4j 提供的一种高效的<span style="color: rgb(255, 85, 0);"><b>二进制协议</b></span>，用于<span style="color: rgb(255, 85, 0);"><b>客户端和 Neo4j 之间</b></span>的通信，称为 <span style="color: rgb(255, 85, 0);"><b>Bolt协议</b></span>。它用于快速、低延迟的数据库操作，特别适合<b><span style="color: rgb(255, 85, 0);">大规模的数据库查询和事务</span></b>。</div>
</div>
<div class="card">
<div class="field_0">Bolt 协议 (bolt://) 和&nbsp;HTTP 协议 (http://) 这两个协议用途的区别是什么？</div>
<div class="separator"></div>
<div class="field_1"><li><strong>Bolt 协议</strong> (<code>bolt://</code>) 是一种二进制协议，专为<span style="color: rgb(255, 85, 0);"><b>高效的数据库交互</b></span>设计，通常用于<b><span style="color: rgb(255, 85, 0);">编程接口和客户端库</span></b>。</li><li><strong>HTTP 协议</strong> (<code>http://</code>) 是用于通过 <b><span style="color: rgb(255, 85, 0);">Web 浏览器访问 Neo4j </span></b>浏览器界面的协议（默认端口是 7474）。</li></div>
</div>
<div class="card">
<div class="field_0">py2neo 是否支持直接通过 HTTP 协议进行连接Neo4j&nbsp;。</div>
<div class="separator"></div>
<div class="field_1">不支持，仅支持 Bolt 协议。</div>
</div>
<div class="card">
<div class="field_0">在 Neo4j 浏览器中，如果你想一次性删除所有的记录（包括节点和关系），可以执行什么 Cypher 查询语句？</div>
<div class="separator"></div>
<div class="field_1">MATCH (n)<br>DETACH DELETE n</div>
</div>
<div class="card">
<div class="field_0">MATCH (n)<br>DETACH DELETE n<br>&nbsp;<br>上面的Cypher 查询语句，分别是什么 意思？</div>
<div class="separator"></div>
<div class="field_1"><li><code>MATCH (n)</code>：匹配数据库中的所有节点。</li><li><code>DETACH DELETE n</code>：删除所有节点，并且同时删除这些节点之间的关系（<code>DETACH</code> 确保相关联的关系也被删除）。</li></div>
</div>
<div class="card">
<div class="field_0">在终端（命令提示符或 PowerShell）启动 Neo4j，使用什么命令？</div>
<div class="separator"></div>
<div class="field_1">neo4j.bat console</div>
</div>
<div class="card">
<div class="field_0">固定的复习时间，一天至少几次?以及分别是什么时候？<br>一天至少三次，分别是早起上厕所时候，吃完午饭之后午休之前，以及晚上睡前。</div>
<div class="separator"></div>
<div class="field_1"><ol><li>清晨：利用<b><span style="color: rgb(255, 85, 0);">早晨起床后【在上厕所的时候】</span></b>的时间，大脑较为清醒，适合进行第一次复习</li><li>午间：在<b><span style="color: rgb(255, 85, 0);">午餐后、午休前的空档</span></b>，是进行知识巩固的理想时机</li><li>晚上：<b><span style="color: rgb(255, 85, 0);">睡前</span></b>进行最后一次复习，有助于记忆的长期保持</li></ol></div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，分别是利用了什么工具？</div>
<div class="separator"></div>
<div class="field_1"><ol><li>Anki闪卡系统，</li><li>Edge浏览器，</li><li>纸和笔来绘制思维导图。</li></ol><br></div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，第一阶段：主动记忆，使用了什么工具以及这个策略的核心理念是什么？</div>
<div class="separator"></div>
<div class="field_1">Anki闪卡系统<br>间隔重复学习 以及 主动回忆。</div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，第二阶段：听觉强化，使用了什么工具以及这个策略的核心理念是什么？</div>
<div class="separator"></div>
<div class="field_1">Edge浏览器的朗读功能，<br>在听取过程中训练预测能力，积极思考下一句内容。</div>
</div>
<div class="card">
<div class="field_0">有效的复习过程可以分为三个递进阶段，从知识输入到最终输出形成完整的学习闭环，第三阶段：知识输出，使用了什么工具以及这个策略的核心理念是什么？</div>
<div class="separator"></div>
<div class="field_1">纸和笔，<br>在<span style="color: rgb(255, 85, 0);"><b>不依赖任何参考资料</b></span>的情况下，将脑中所学知识通过<b><span style="color: rgb(255, 85, 0);">思维导图的形式可视化</span></b></div>
</div>
<div class="card">
<div class="field_0">每天早晨上厕所时，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">快速<b><span style="color: rgb(255, 85, 0);">浏览昨天晚上</span></b>通过Edge浏览器朗读功能来复习的内容。</div>
</div>
<div class="card">
<div class="field_0">每天早晨上完厕所后，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">不参考资料的情况下，进行思维导图的绘制。</div>
</div>
<div class="card">
<div class="field_0">每天晚上睡前，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">利用<span style="color: rgb(255, 85, 0);"><b>Edge</b></span>浏览器的<span style="color: rgb(255, 85, 0);"><b>朗读</b></span>功能，将已复习过的笔记<span style="color: rgb(255, 85, 0);"><b>转化为音频</b></span>。<br>在听的过程中，<b><span style="color: rgb(255, 85, 0);">积极思考</span></b>下一句内容。</div>
</div>
<div class="card">
<div class="field_0">每天午休前，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">跟睡前的复习活动一样，<br>利用<span style="color: rgb(255, 85, 0);"><b>Edge</b></span>浏览器的<span style="color: rgb(255, 85, 0);"><b>朗读</b></span>功能，将已复习过的笔记<span style="color: rgb(255, 85, 0);"><b>转化为音频</b></span>。<br>在听的过程中，<b><span style="color: rgb(255, 85, 0);">积极思考</span></b>下一句内容。</div>
</div>
<div class="card">
<div class="field_0">每天午休醒来后，进行什么样的复习活动？</div>
<div class="separator"></div>
<div class="field_1">不参考资料的情况下，进行思维导图的绘制。</div>
</div>
<div class="card">
<div class="field_0">IV的作用 是什么？【这个值越大表示这个特征的什么能力越强。】</div>
<div class="separator"></div>
<div class="field_1">对目标变量的区分能力以及预测能力越强。<br><br>衡量了整个特征对目标变量的区分能力，IV值越大，特征的预测能力越强。</div>
</div>
<div class="card">
<div class="field_0">多分类问题中最常用的评估指标，尤其是在类别分布平衡的情况下，是什么？</div>
<div class="separator"></div>
<div class="field_1">准确度（Accuracy）&nbsp;</div>
</div>
<div class="card">
<div class="field_0">准确度（Accuracy）计算公式是什么？</div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-1f6be0413a5f5e912755f93ebbd58f9a7abdbb9b.jpg"></div>
</div>
<div class="card">
<div class="field_0">词性标注 的英文以及简写是什么？<br><div></div></div>
<div class="separator"></div>
<div class="field_1">Part-of-Speech Tagging, POS Tagging</div>
</div>
<div class="card">
<div class="field_0">jieba 分词里面的<br>精确模式、全模式和搜索引擎模式的区别<br><div></div></div>
<div class="separator"></div>
<div class="field_1"><ul><li>精确模式：输出是<span style="color: rgb(255, 85, 0);"><b>唯一的，没有重复词</b></span>，也不会刻意把一个长词再切分成短词。</li><li>全模式和搜索引擎模式：都<span style="color: rgb(255, 85, 0);"><b>包含重复词。<br></b></span></li><li>全模式：穷尽句子中的所有词语组合，导致<b><span style="color: rgb(255, 85, 0);">重复率较高。</span></b></li><li>搜索引擎模式：在<b><span style="color: rgb(255, 85, 0);">精确模式基础上增加长词的细分。</span></b></li></ul></div>
</div>
<div class="card">
<div class="field_0">分词 的英文是什么？<div></div></div>
<div class="separator"></div>
<div class="field_1">Tokenization。</div>
</div>
<div class="card">
<div class="field_0"><img src="images/paste-ab996a7e59f9a4baaeb6813eb5c19b31782db97b.jpg"></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-c672aae18d77ff9ec86630b2669d1faf82b6c213.jpg"></div>
</div>
<div class="card">
<div class="field_0">在GRU里面，下面公式中间的圈是什么意思？以及整体的功能是什么？<br><img src="images/paste-046c39aca8b8ba1a061d9e2fce09a1762cefc82c.jpg"></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-3caadf5deda77e771733c197199cdc5eab2a2a18.jpg"></div>
</div>
<div class="card">
<div class="field_0">在GRU里面，1 - z_t 和 z_t 分别过滤什么信息？</div>
<div class="separator"></div>
<div class="field_1">分别是旧信息，上个隐藏状态<br>以及新信息，当前候选状态。<br><img src="images/paste-a6df9ac7f10683554224a09cd7e1bce53f2a7b93.jpg"><br><img src="images/paste-d7895d85322460c397501a52348e55c6853cd99a.jpg"></div>
</div>
<div class="card">
<div class="field_0">在GRU里面，<br>最终的隐藏状态h_t是谁和谁的加权融合？</div>
<div class="separator"></div>
<div class="field_1">新旧信息的加权融合，新信息就是新的候选状态，旧信息就是上一个隐藏状态。<br><img src="images/paste-5ce25af2106baf8b499e2f280759ca44170c50c5.jpg"></div>
</div>
<div class="card">
<div class="field_0">GRU 的完整数据流程包括哪三个关键步骤？</div>
<div class="separator"></div>
<div class="field_1"><li>计算两个门的值（z_t​ 和 r_t​）。</li><li>生成当前时间步的候选隐藏状态&nbsp;<img src="images/paste-b31a59048c6e4e26268aee3175d5172d769104ce.jpg">。</li><li>更新隐藏状态 h_t​。</li></div>
</div>
<div class="card">
<div class="field_0">GRU 里面，<br><img src="images/paste-5d69acb8c8db2d3663493689d3d59586b0ba70be.jpg"></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-cb1b0b4790d58286a6557a723ce4fc6cda35bdfc.jpg"></div>
</div>
<div class="card">
<div class="field_0"><img src="images/paste-aa1dfa78b3826554052b63cbc999b08261a5d934.jpg"><br>在 LSTM 中，<br>输出门（output gate）的功能是什么？【决定了哪里的信息传递到哪。】</div>
<div class="separator"></div>
<div class="field_1">&nbsp;输出门（output gate）决定了细胞状态中的信息有多少需要传递给隐藏状态，也就是决定隐藏状态的值。</div>
</div>
<div class="card">
<div class="field_0"><img src="images/paste-2e8db9759fae17dde03fa36dc391553dfbcc281a.jpg"></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-713e8ee9c88ad0c5808be4529e12ddd718454dd8.jpg"></div>
</div>
<div class="card">
<div class="field_0">collate_fn 应返回什么样的数据？【返回的数据的格式以及参数名称。】 </div>
<div class="separator"></div>
<div class="field_1">返回的格式是具有两个元素的元组，而第一个元素又是一个三个元素的元组。<br><br>((<span style="color: rgb(255, 85, 0);"><b>batched_x</b></span>, batched_seq_len, batched_mask), <b><span style="color: rgb(255, 85, 0);">batched_y</span></b>)</div>
</div>
<div class="card">
<div class="field_0"><ol><li>使用 pathlib 来确保路径存在</li><li>使用动态生成的时间戳作为模型名称</li></ol>使用这两种方式来优化下面代码。<br><br>torch.save(ba_model.state_dict(), './save_model/20230228_new_model_%d.bin' % epoch)<br></div>
<div class="separator"></div>
<div class="field_1"># 生成当前的时间戳<br>timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')<br><br># 定义保存模型的目录<br>save_path = Path('./save_model')<br><br><br>save_path.mkdir(parents=True, exist_ok=True)<br><br># 保存模型<br>torch.save(ba_model.state_dict(), save_path/ f"{timestamp}.bin)</div>
</div>
<div class="card">
<div class="field_0">如何在模型中处理 EPO 问题</div>
<div class="separator"></div>
<div class="field_1">对于 EPO 问题，可以将关系抽取任务视为多标签多分类问题，使模型能够为同一实体对预测多个关系。</div>
</div>
<div class="card">
<div class="field_0">如何在模型中处理 SEO 问题?</div>
<div class="separator"></div>
<div class="field_1">对于 SEO 问题，可以为每个实体对设计独立的分类器，或者使用共享层和专用层结合的架构，以区分不同实体对中的关系。</div>
</div>
<div class="card">
<div class="field_0">nn.Embedding(<b><span style="color: rgb(255, 85, 0);">..., ...</span></b>) 初始化一个嵌入矩阵<br>里面的两个参数名称是什么？</div>
<div class="separator"></div>
<div class="field_1">(vocab_size, embedding_dim)</div>
</div>
<div class="card">
<div class="field_0"><div>在关系抽取中，标签类别tag通常对应于什么？<br></div></div>
<div class="separator"></div>
<div class="field_1">对应于不同的关系类型。</div>
</div>
<div class="card">
<div class="field_0"><div>注意力机制（Attention Mechanism）<div>作用是使模型能够在处理序列数据时，能够怎么样？</div></div>【能够动态怎么样？提升模型的什么能力？】</div>
<div class="separator"></div>
<div class="field_1">动态地关注输入序列中的不同部分。提升模型对重要信息的捕捉能力，增强上下文理解。</div>
</div>
<div class="card">
<div class="field_0">inner_obj_heads 和 inner_obj_tails 的维度是 什么样的？【是二维的，行数和列数分别和什么相等？】</div>
<div class="separator"></div>
<div class="field_1">[序列长度, 关系类别数].</div>
</div>
<div class="card">
<div class="field_0">inner_obj_heads 和 inner_obj_tails,数据格式是存放0,1&nbsp;二值的二维矩阵。<br>每个位置的0,1 表示什么意思？【什么类别下的什么位置？】</div>
<div class="separator"></div>
<div class="field_1">特定关系类别下的起止位置。</div>
</div>
<div class="card">
<div class="field_0"><div>从输入句子，到Token Embedding，Position Embedding。整体的数据流转过程是什么样？【4个步骤】</div></div>
<div class="separator"></div>
<div class="field_1">1 原始文本序列经过tokenizer处理以后变成id序列。<br>2 ID序列里面的每个ID经过embedding 层后得到对应的嵌入词向量。<br>3 每个位置索引经过嵌入以后得到位置向量。<br>4 词向量和每个对应的位置向量相加以后得到结果。<br><br><div><strong>步骤1：Tokenization</strong></div><ul><li>输入句子被<b><span style="color: rgb(255, 85, 0);">分割成 tokens</span></b>，并转换为 <b><span style="color: rgb(255, 85, 0);"><code>input_ids</code></span></b>。</li></ul><div><strong>步骤2：Token Embedding</strong></div><ul><li>每个 <code>input_id</code> 被<span style="color: rgb(255, 85, 0);"><b>转换为一个嵌入向量</b></span>，形成 <b><span style="color: rgb(255, 85, 0);"><code>token_embeddings</code> </span></b>矩阵。</li></ul><div><strong>步骤3：Position Embedding</strong></div><ul><li>每个 token 的<b><span style="color: rgb(255, 85, 0);">位置索引</span></b> 形成 <span style="color: rgb(255, 85, 0);"><b><code>position_embeddings</code> </b></span>矩阵。</li></ul><div><strong>步骤4：相加操作</strong></div><ul><li>将 <b><span style="color: rgb(255, 85, 0);"><code>token_embeddings</code> 和 <code>position_embeddings</code> 相加</span></b>，得到结合了词汇和位置信息的最终输入表示。</li></ul></div>
</div>
<div class="card">
<div class="field_0">def create_label(inner_triples, inner_input_ids, seq_len):<br>代码里面，这三个参数分别是什么意思？</div>
<div class="separator"></div>
<div class="field_1">包含SPO三元组的列表。词汇表里面的ID序列。序列的长度。<br><ul><li>inner_triples: 包含多个SPO三元组的列表，每个三元组包含 subject、predicate、object。</li><li>inner_input_ids:  各个token在词汇表里面对应的ID位置序号。</li><li>seq_len: 序列长度。</li></ul><div></div></div>
</div>
<div class="card">
<div class="field_0">inner_triples 是一个包含多个SPO三元组的列表，后续用它来构建什么？</div>
<div class="separator"></div>
<div class="field_1">遍历 inner_triples 并构建 s2ro_map。</div>
</div>
<div class="card">
<div class="field_0">inner_triples 是一个包含多个SPO三元组的列表，首先对其遍历，拿到单个的三元组之后，然后是什么阶段？【是什么阶段以及三元组里面哪些值分别通过什么？转换成什么？】</div>
<div class="separator"></div>
<div class="field_1">编码阶段，<br><ul><li>将 subject 和 object 通过 tokenizer 转换为 input_ids。</li><li>将predicate 通过字典的映射，转换为对应的关系ID。</li></ul></div>
</div>
<div class="card">
<div class="field_0">处理的流程是什么？【从原始的输入文本到用于训练的标签张量】</div>
<div class="separator"></div>
<div class="field_1"><div><ol><li>输入：句子经过tokenizer处理，得到 input_ids。</li><li>遍历SPO三元组：对每个SPO三元组，找到主体和客体实体在 input_ids 中的起始索引。</li><li>构建 s2ro_map：s2ro_map 记录了每个主体实体所关联的所有客体实体及其关系类别。</li><li>填充标签：关于主体的话有四个，sub_head, sub_tail, sub_head2tail, sub_len，关于客体的话有两个obj_head, obj_tail。</li><li>输出：返回用于训练的多个标签张量，涵盖主体实体的位置、跨度、长度，以及客体实体的位置和关系类别。</li></ol></div></div>
</div>
<div class="card">
<div class="field_0">假设我们有以下句子和SPO三元组，经过tokenizer处理后的 input_ids 和位置索引应该是什么样的？<br><div>&nbsp;<div></div></div>句子: "Alice works at OpenAI and studies at MIT."<br><br>SPO三元组:<br>1. {'subject': 'Alice', 'predicate': 'works_at', 'object': 'OpenAI'}<br>2. {'subject': 'Alice', 'predicate': 'studies_at', 'object': 'MIT'}<br><br></div>
<div class="separator"></div>
<div class="field_1">input_ids = [101, 1001, 2003, 2000, 2001, 2004, 2005, 2006, 2007, 102]<br># 对应的tokens: ["[CLS]", "Alice", "works", "at", "OpenAI", "and", "studies", "at", "MIT", "[SEP]"]<br># 位置索引:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,&nbsp;&nbsp;&nbsp;&nbsp; 4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7,&nbsp;&nbsp;&nbsp; 8,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9]</div>
</div>
<div class="card">
<div class="field_0">使用inner_sub_head2tail 0,1 二值的一维张量，来标记主体实体的跨度。【代码】</div>
<div class="separator"></div>
<div class="field_1">inner_sub_head2tail[sub_head_idx: sub_tail_idx + 1] = 1</div>
</div>
<div class="card">
<div class="field_0"> EPO 问题为什么被视为多标签多分类任务，使用什么激活函数以及损失函数？<div></div>以及为什么？</div>
<div class="separator"></div>
<div class="field_1">Entity pair overlap意味着同一实体对之间存在多个关系标签。也就是对于单个实体对而言，他属于是多标签，多分类。<br>sigmoid + BCE loss。<br>多标签多分类任务通常会被视为2分类任务，所以的话它对应的是sigmoid和2元交叉熵损失。</div>
</div>
<div class="card">
<div class="field_0"><div>[json.loads(line) for line in open(data_path, encoding='utf-8')]<br></div><div>这个写法，虽然技术上可行，但不推荐，这是为什么呢？</div><div></div></div>
<div class="separator"></div>
<div class="field_1">因为缺乏资源管理，可能导致文件未关闭的问题。</div>
</div>
<div class="card">
<div class="field_0">heads = torch.arange(0, len(pred_sub_heads), device='cpu')[pred_sub_heads == 1]<br>代码执行的两个阶段是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>生成<b><span style="color: rgb(255, 85, 0);">位置索引</span></b> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]，</li><li>pred_sub_heads == 1 得到<span style="color: rgb(255, 85, 0);"><b>布尔张量</b></span>来 <span style="color: rgb(255, 85, 0);"><b>筛选</b></span>出 的位置索引，得到 <b><span style="color: rgb(255, 85, 0);">heads </span></b>。</li></ul></div>
</div>
<div class="card">
<div class="field_0">extract_sub 这个函数输出的变量的名称是什么以及他的格式是什么？</div>
<div class="separator"></div>
<div class="field_1">subs，<br>类似于[(0, 8), (6, 9)]，包含多个二元元组的列表。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输出参数是pooler_output ，通常是 哪个token的向量经过哪两个步骤之后的结果，用作表示什么？</div>
<div class="separator"></div>
<div class="field_1">&nbsp;[CLS] token 的向量，一个全连接层和 Tanh 激活函数后，用于句子级别的表示（即句向量）。</div>
</div>
<div class="card">
<div class="field_0">BERT 模型 主要输出参数是last_hidden_state，包含什么信息？</div>
<div class="separator"></div>
<div class="field_1">每个token的词向量。<br>每个 token 的上下文相关向量表示（即词向量）。</div>
</div>
<div class="card">
<div class="field_0">Tokenizer 的输出结果输入到模型之后，来到bert模型里面的Transformer编码器，处理什么数据，生成什么数据。</div>
<div class="separator"></div>
<div class="field_1">处理输入嵌入，生成隐藏状态（hidden states）。</div>
</div>
<div class="card">
<div class="field_0">联合抽取方法分类为哪两种？</div>
<div class="separator"></div>
<div class="field_1"><ul><li><b><span style="color: rgb(255, 85, 0);">参数共享</span></b>的联合模型，级联的方式</li><li><b><span style="color: rgb(255, 85, 0);">联合解码</span></b>的联合模型。</li></ul></div>
</div>
<div class="card">
<div class="field_0">相比于管道模型，联合模型的核心在于哪两个方面？</div>
<div class="separator"></div>
<div class="field_1">任务间的参数共享和使用一个共同的总的损失函数。</div>
</div>


<script>
document.addEventListener('click', function(e) {
const container = e.target.closest('.video-container');
if (!container) return;

const placeholder = container.querySelector('.video-placeholder');
if (!placeholder) return;

const videoId = container.dataset.videoId;
const startParam = container.dataset.start || '';

const iframe = document.createElement('iframe');
iframe.width = '100%';
iframe.height = '100%';
iframe.src = `https://www.youtube.com/embed/${videoId}?${startParam.slice(1)}`;
iframe.title = 'YouTube video player';
iframe.frameBorder = '0';
iframe.style.position = 'absolute';
iframe.style.top = '0';
iframe.style.left = '0';
iframe.style.borderRadius = '15px';
iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
iframe.allowFullscreen = true;

placeholder.innerHTML = '';
placeholder.appendChild(iframe);
});
</script>

</div>
<div class="footer">Made by <a href="https://xxhk.org">Export Notes - XXHK</a></div>
</body>
</html>

