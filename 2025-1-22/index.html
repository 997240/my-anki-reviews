
<html>
<head>
<meta charset="UTF-8">
<title>Export Notes by xxhk.org</title>
<style>

body { font-family: Arial, sans-serif; }
.card { border: 2px solid #000; padding: 10px; border-radius: 10px; margin-bottom: 20px; }
img {
max-width: 100%;
height: auto;
border: 1px solid lightgray;
border-radius: 10px;
display: inline-block;
margin: 10px 0px;
}
.separator { border-top: 1px dashed #000; margin: 10px 0; }
.tags { background-color: lightgray; padding: 5px 10px; margin-bottom: 10px; border-radius: 5px; display: inline-block; }
.footer {
text-align: center;
color: grey;
margin-top: 20px;
padding: 10px;
}

.video-container {
margin: 10px 0;
}
.video-placeholder {
position: relative;
cursor: pointer;
}
.play-button {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 68px;
height: 48px;
background-color: rgba(0, 0, 0, 0.7);
border-radius: 14px;
cursor: pointer;
}
.play-button::before {
content: '';
position: absolute;
top: 50%;
left: 55%;
transform: translate(-50%, -50%);
border-style: solid;
border-width: 12px 0 12px 20px;
border-color: transparent transparent transparent white;
}
.play-button:hover {
background-color: red;
}

</style>

</head>
<body>
<div id="cards-container">
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">Prompt Tuning 是一种高效的模型适应方法，旨在将什么调整以适应什么任务，而无需怎么样？</div>
<div class="separator"></div>
<div class="field_1">预训练语言模型（如GPT系列、BERT等），特定的下游任务，无需对整个模型进行微调。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P Tuning 通过优化一组什么样的向量，将这些向量插入到模型的哪里，从而引导模型怎么样？</div>
<div class="separator"></div>
<div class="field_1">连续的、可训练的提示（prompt）的向量，模型的输入中，引导模型生成符合特定任务要求的输出。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P Tuning 过程中，冻结预训练模型是什么意思？【优化谁而什么不变？】</div>
<div class="separator"></div>
<div class="field_1">在训练过程中，<span style="color: rgb(255, 85, 0);"><b>仅优化</b></span>这些<span style="color: rgb(255, 85, 0);"><b>提示向量的参数</b></span>，而保持预训练模型的<b><span style="color: rgb(255, 85, 0);">其他参数不变</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P Tuning 过程中，任务适应 是什么意思？【通过什么优化方法来调整什么？】</div>
<div class="separator"></div>
<div class="field_1">任务适应：通过<span style="color: rgb(255, 85, 0);"><b>梯度下降</b></span>等优化方法，<b><span style="color: rgb(255, 85, 0);">调整提示向量</span></b>，使其在特定任务上引导模型产生最佳性能。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">相比于微调整个模型，Prompt Tuning 的优势是什么？【显著减少了什么？】</div>
<div class="separator"></div>
<div class="field_1">Prompt Tuning 只需<span style="color: rgb(255, 85, 0);"><b>优化少量的提示向量</b></span>，显著<b><span style="color: rgb(255, 85, 0);">减少了训练参数。</span></b></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">Prompt Tuning 的中文名称是什么？</div>
<div class="separator"></div>
<div class="field_1">提示调优。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P-Tuning v1 通过在模型的哪里插入多个什么（通常称为“哪个英文单词”）。</div>
<div class="separator"></div>
<div class="field_1">输入层，插入多个连续的提示向量，称为prefix。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P-Tuning v1 通过在模型的输入层插入多个连续的提示向量（通常称为“prefix”），这些向量在哪里进行传递和调整。</div>
<div class="separator"></div>
<div class="field_1">整个模型的多个层级中进行传递和调整。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P-Tuning v1 的多层提示是什么意思？【不仅在哪里插入提示，还在哪里插入？】</div>
<div class="separator"></div>
<div class="field_1">不仅在输入层插入提示，还在模型的中间层插入提示向量，使得提示信息能够在更深层次影响模型的表示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P-Tuning v1 的多层提示是不仅在输入层插入提示，还在模型的中间层插入提示向量，使得提示信息能够怎么样？</div>
<div class="separator"></div>
<div class="field_1">能够在更深层次影响模型的表示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在 P-Tuning v1 的基础上，P-Tuning v2&nbsp;更深层次的集成，提示向量不仅在中间层插入，还可能在更深层次或更细粒度的层级进行集成，使得提示信息能够怎么样？</div>
<div class="separator"></div>
<div class="field_1">更全面地影响模型的各个部分。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P-Tuning v1 和 P-Tuning v2&nbsp; ，在提示结构上的区别是什么？</div>
<div class="separator"></div>
<div class="field_1">P-Tuning v1 主要在输入层和部分中间层插入提示向量，而 P-Tuning v2 则在更多层级和更灵活的方式中集成提示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">传统上，如果你想让像GPT这样的模型完成一个新任务，通常需要怎么做，以及这样的效果是什么？<br>而 P Tuning 的做法是，什么样的?</div>
<div class="separator"></div>
<div class="field_1"><ul><li><span style="color: rgb(255, 85, 0);"><b>微调</b></span>整个模型，这样做不仅<span style="color: rgb(255, 85, 0);"><b>耗时</b></span>还需要大量的<b><span style="color: rgb(255, 85, 0);">计算资源</span></b>。</li><li>只调整一小部分叫做<b><span style="color: rgb(255, 85, 0);">“提示向量”</span></b>的参数，这些提示向量就像是给模型的小提示，告诉它该怎么做。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">P-Tuning v2 是 P Tuning v1 的一个升级版，意思是“增强提示调优”。如何理解？【不仅在哪里添加提示向量，而且怎么样。】</div>
<div class="separator"></div>
<div class="field_1">它不仅仅是在模型的输入层加提示向量，还会在模型的多个层级中插入这些提示，让提示信息能更深入地影响模型的处理过程。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><img src="images/paste-1f25bffb05ed25ecb76b8e2ad906ae6a0758b6b1.jpg"></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-ae62fb7da07199d4ef4ee8dd746a4546e6824769.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><img src="images/paste-364cf008166ed504ddd2ea432aea67f091721714.jpg"></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-ae62fb7da07199d4ef4ee8dd746a4546e6824769.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><img src="images/paste-213c28f96c2c4f7594997f0c0b2e6ea8b368744c.jpg"><br></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-ae62fb7da07199d4ef4ee8dd746a4546e6824769.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><img src="images/paste-5f1af5fa81f2708d09a29f4ea2078504d538ccfe.jpg"></div>
<div class="separator"></div>
<div class="field_1"><img src="images/paste-ae62fb7da07199d4ef4ee8dd746a4546e6824769.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">指代消解和实体消歧，这两个技术分别解决是什么词的问题？</div>
<div class="separator"></div>
<div class="field_1">指代消解<span style="color: rgb(0, 0, 0);">&nbsp;</span>解决的是指<span style="color: rgb(255, 0, 0);"><b>代词</b></span>指向的问题，
<br>另一个解决的是<b><span style="color: rgb(255, 0, 0);">多义词</span></b>的问题</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">指代消解（Coreference Resolution）的作用范围以及目标是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li><strong>作用范围</strong>：<strong>文本内部</strong></li><li><strong>目标</strong>：在一段文本中，确定不同的词语或短语是否指向同一个实体。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">实体消歧（Entity Disambiguation）的作用范围以及目标是什么？</div>
<div class="separator"></div>
<div class="field_1"><li><strong>作用范围</strong>：<strong>文本与知识库之间</strong></li><li><strong>目标</strong>：将文本中的一个模糊或多义的实体提及，链接到知识库中唯一且具体的实体。</li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">指代消解（Coreference Resolution）和实体消歧（Entity Disambiguation）<br>分别对应的核心问题是什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>这段话中，这些词指的是<span style="color: rgb(255, 0, 0);"><b>同一个实体</b></span>吗？<span style="color: rgb(255, 0, 0);">&nbsp;</span></li><li>这个<span style="color: rgb(255, 0, 0);"><b>名称</b></span>在<span style="color: rgb(255, 0, 0);"><b>知识库中</b></span>具体指的是哪个<b><span style="color: rgb(255, 0, 0);">实体</span></b>？</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在知识融合阶段，使用什么技术，以确保从不同数据源中提取和整合的信息准确且一致。</div>
<div class="separator"></div>
<div class="field_1"><div>指代消解，实体消歧。</div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">指代消解和实体消歧的区别是什么？【面试回答】</div>
<div class="separator"></div>
<div class="field_1">指代消解和实体消歧是知识融合阶段中两个重要但不同的技术。指代消解主要用于识别文本中不同表达是否指向同一实体，例如将‘他’指代到前文提到的具体人物。而实体消歧则用于确定一个实体提及在知识库中对应的具体实体，例如区分‘Apple’是指苹果公司还是水果。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">实体对齐（Entity Alignment）和关系对齐（Relation Alignment）是知识图谱融合过程中两个关键但不同的任务。虽然它们在目标上有相似之处，这个相似之处是什么？【统一什么来消除什么？】</div>
<div class="separator"></div>
<div class="field_1">即通过<span style="color: rgb(255, 85, 0);"><b>统一不同数据源中的表示</b></span>来<b><span style="color: rgb(255, 85, 0);">消除歧义性/冗余</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">实体对齐确保了什么？【谁在哪里的唯一表示？】</div>
<div class="separator"></div>
<div class="field_1">确保了<span style="color: rgb(255, 85, 0);"><b>文本中的同一实体</b></span>在知识<span style="color: rgb(255, 85, 0);"><b>图谱</b></span>中只有一个<b><span style="color: rgb(255, 85, 0);">唯一的表示</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">通过实体对齐和关系对齐，我们能够消除什么？</div>
<div class="separator"></div>
<div class="field_1">消除不同数据源之间的冗余和不一致性。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">槽位是否等同于关键词？</div>
<div class="separator"></div>
<div class="field_1">不是，槽位是关键词的类别，槽位值才是是关键词。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">槽位填充不仅仅是提取关键词，而是什么？</div>
<div class="separator"></div>
<div class="field_1">将这些提取到的关键词 注入到 预定义的“槽”中。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">CasRel模型属于联合级联模型，那么该如何理解“联合”与“级联”这两个概念的含义呢？</div>
<div class="separator"></div>
<div class="field_1">所谓“联合”，是指在一个模型中同时处理实体识别与关系抽取这两项任务。也就是说，这两个任务共享同一个BERT模型输出的语义层。在训练过程中，获取总损失后进行反向传播，进而同步更新参数。而“级联”则是指在预测过程中，这两个任务按先后顺序执行，先进行实体识别，之后再开展关系抽取。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">交叉熵损失函数包含哪两个阶段？它们在公式中对应的英文符号分别是什么？</div>
<div class="separator"></div>
<div class="field_1">这两个阶段分别是<br>SoftMax归一化，对应符号为s；<br>负对数函数，在公式中对应的是 -log。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">请用一句话描述交叉熵损失函数的操作步骤。</div>
<div class="separator"></div>
<div class="field_1">将概率分布的对数值与真实标签的独热编码相乘，累计求和后取其负值。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">自编码模型的核心是先对数据进行编码，再进行解码。其中一种实现方式是MLM，那么另一种方式是什么呢？</div>
<div class="separator"></div>
<div class="field_1">另一种方式是将数据压缩为更小的表示形式，随后再还原为原始数据。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">自编码模型和自回归模型的核心本质是使用了不同的mask。分别指的是什么？</div>
<div class="separator"></div>
<div class="field_1">自编码模型的核心在于采用了MLM预训练任务；<br>自回归模型的核心则是运用了后续掩码，使得模型无法获取未来信息。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在pipeline方式中，实体抽取和关系抽取分别采用了什么模型？</div>
<div class="separator"></div>
<div class="field_1">实体抽取采用的是BiLSTM加CRF模型，<br>关系抽取采用的是BiLSTM加Attention模型。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">困惑度用于衡量什么？【预测单词的角度。】</div>
<div class="separator"></div>
<div class="field_1">它衡量的是预测每个单词时平均有多少种分支或可能性。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">需将数据处理成何种格式的文件才能插入Neo4j？插入Neo4j时采用了什么具体步骤？</div>
<div class="separator"></div>
<div class="field_1">需将数据处理为JSONL格式，每行都是一个字典，每个字典包含spo三元组。<br>循环遍历这些三元组，将其拼接到Cypher查询模板中构成查询语句，然后插入到Neo4j数据库中。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">L1正则化 和&nbsp;L2正则化，分别的使用场景是什么？【分别对权重和特征的影响是什么？】</div>
<div class="separator"></div>
<div class="field_1">L1则是将一些权重归零，实现特征选择。<br>L2则是保留所有的权重，但是呢权重都普遍偏小，但是所有特征都有贡献。<br><ul><li>L1：希望模型参数<b><span style="color: rgb(255, 0, 127);">稀疏化</span></b>，即将<span style="color: rgb(255, 0, 127);"><b>一些权重变为零</b></span>，从而实现<span style="color: rgb(255, 0, 127);"><b>特征选择</b></span>。</li><li>L2：当希望<span style="color: rgb(255, 0, 127);"><b>所有特征都有贡献</b></span>，但<b><span style="color: rgb(255, 0, 127);">不希望某些权重过大</span></b>时。防止模型权重过大，减小模型复杂度，提升模型的泛化能力。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">训练 深度学习模型（如BERT、BiLSTM）时，可以在哪里加入L1和L2正则化项。</div>
<div class="separator"></div>
<div class="field_1">模型的损失函数中。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">L1 和 L2正则化，谁用于约束模型权重，提升泛化能力，谁用于特征选择?</div>
<div class="separator"></div>
<div class="field_1">L1正则化用于特征选择，L2正则化用于约束模型权重，提升泛化能力。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">RAG主要功能是根据用户提出的问题，通过什么搜索从本地数据库中检索相关文档内容，构建什么，并利用大型语言模型生成专业且简洁的回答。</div>
<div class="separator"></div>
<div class="field_1">向量相似性搜索，检索相关文档内容，构建上下文提示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">使用什么将本地文档转化为向量，并加载存储在什么数据库。</div>
<div class="separator"></div>
<div class="field_1">使用预训练的嵌入模型，FAISS中的向量数据库。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">RAG构建提示模板：将什么和什么结合，形成供LLM的提示信息prompt。</div>
<div class="separator"></div>
<div class="field_1">将检索到的上下文信息与用户问题结合。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">RAG里面，使用哪个嵌入模型？</div>
<div class="separator"></div>
<div class="field_1">mxbai-embed-large。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">mxbai-embed-large的嵌入模型，将什么转换为什么。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">将文本转化为向量表示</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">mxbai-embed-large的嵌入模型，将文本转化为向量表示。<br>这种表示方式能捕捉什么，使得相似文本在哪里距离更近。</div>
<div class="separator"></div>
<div class="field_1">捕捉文本的语义信息，在向量空间中。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">FAISS数据库 的全称是什么？</div>
<div class="separator"></div>
<div class="field_1">FAISS（Facebook AI Similarity Search）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">通过FAISS.xxx方法加载本地存储的向量数据库faiss/wuliu</div>
<div class="separator"></div>
<div class="field_1">load_local。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">利用加载的FAISS数据库，k=2 是什么意思？</div>
<div class="separator"></div>
<div class="field_1">根据用户的问题进行相似性搜索，检索出与问题最相关的前2篇文档。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PromptTemplate这个类是定义什么？【包含哪两方面内容的模板？】</div>
<div class="separator"></div>
<div class="field_1">定义一个包含上下文和问题的模板。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">embeddings = <span style="color: rgb(255, 0, 127);"><b>OllamaEmbeddings</b></span>(model="mxbai-embed-large", temperature=0)<br>db = <b><span style="color: rgb(255, 0, 127);">FAISS.load_local</span></b>("faiss/wuliu", embeddings)<br><br>这两行代码的作用是什么？</div>
<div class="separator"></div>
<div class="field_1">初始化嵌入模型，<br>加载本地FAISS向量数据库。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">利用ollama，初始化嵌入模型并加载本地FAISS向量数据库。<br><br>使用的那两个api？</div>
<div class="separator"></div>
<div class="field_1"><br>embeddings =&nbsp;<span style="color: rgb(255, 0, 127);"><b>OllamaEmbeddings</b></span>(model="mxbai-embed-large", temperature=0)<br>db =&nbsp;<b><span style="color: rgb(255, 0, 127);">FAISS.load_local</span></b>("faiss/wuliu", embeddings)</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">docs = db.similarity_search(question, k=2)<br>这行代码的作用是什么？</div>
<div class="separator"></div>
<div class="field_1">相似性搜索：检索与问题最相似的2篇文档。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">相似性搜索：检索与问题最相似的2篇文档。【代码】</div>
<div class="separator"></div>
<div class="field_1">docs = db.similarity_search(question, k=2)</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PROMPT_TEMPLATE = """<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基于以下已知信息，简洁和专业的来回答用户的问题。不允许在答案中添加编造成分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已知内容:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {context}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {question}"""<br>后续的PromptTemplate这个部分怎么写？</div>
<div class="separator"></div>
<div class="field_1">prompt = PromptTemplate(<span style="color: rgb(255, 0, 127);"><b>input_variables</b></span>=["context", "question"],&nbsp;<span style="color: rgb(255, 0, 127);"><b>template</b></span>=PROMPT_TEMPLATE,)<br><br>my_pmt = prompt.<span style="color: rgb(255, 0, 127);"><b>format</b></span>(<span style="color: rgb(255, 0, 127);"><b>context</b></span>=related_content,<b><span style="color: rgb(255, 0, 127);">question</span></b>=question)</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PromptTemplate 这个类里面的两个参数是什么以及分别的类型是什么？</div>
<div class="separator"></div>
<div class="field_1">input_variables 是字符串列表, <br>template是字符串。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">prompt是PromptTemplate的实例化对象，调用哪个方法来拼接问题和答案到模板里面？</div>
<div class="separator"></div>
<div class="field_1">format。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">prompt是PromptTemplate的实例化对象，调用的方法是format，里面的参数名称/形参取决于什么？</div>
<div class="separator"></div>
<div class="field_1">PromptTemplate里面的input_variables这个列表里面的各个字符串。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">加载本地存储的FAISS向量数据库【代码】</div>
<div class="separator"></div>
<div class="field_1">db = FAISS.load_local("faiss/wuliu", embeddings)</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PROMPT_TEMPLATE 是什么格式，内容包含什么？</div>
<div class="separator"></div>
<div class="field_1">是三引号的字符串，包含&nbsp; {context}&nbsp; 以及&nbsp; {question}，<br><br>PROMPT_TEMPLATE = """<br>&nbsp;&nbsp;&nbsp; 基于以下已知信息，简洁和专业的来回答用户的问题。不允许在答案中添加编造成分。<br>&nbsp;&nbsp;&nbsp; 已知内容:<br>&nbsp;&nbsp;&nbsp; {context}<br>&nbsp;&nbsp;&nbsp; 问题:<br>&nbsp;&nbsp;&nbsp; {question}"""</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">测量整个问答过程的执行时间。【三行代码，问答过程前面一行，问答过程后面两行。】</div>
<div class="separator"></div>
<div class="field_1">start_time = time.time()<br>...<br>end_time = time.time()<br>print(end_time-start_time)</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">RAG系统的步骤是什么？【加载什么，进行什么检索，然后构建什么？】</div>
<div class="separator"></div>
<div class="field_1">加载本地向量数据库、进行相似性检索、构建上下文提示，并调用LLM生成回答。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">降级 NumPy 至1.23.5版本，指令是什么？</div>
<div class="separator"></div>
<div class="field_1">pip uninstall numpy<br>pip install numpy==1.23.5</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a[..., 1, None] 里面，在索引中，...（省略号）代表什么意思？</div>
<div class="separator"></div>
<div class="field_1">表示尽可能多的 :（冒号），即选择该维度的所有元素。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a[..., 1, None] 等价于什么？</div>
<div class="separator"></div>
<div class="field_1">&nbsp;a[:, 1, None]。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a[..., 1, None] 里面None 操作符作用是什么？</div>
<div class="separator"></div>
<div class="field_1">在索引中使用 None（或 torch.newaxis）可以在指定位置插入一个新的维度。这个新维度的大小为 1。作用机制：相当于在张量的形状中添加一个新的维度，使得张量的维数增加。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4)<br>b = a[:, 1]<br>print(b.shape)&nbsp; # 输出是什么？</div>
<div class="separator"></div>
<div class="field_1">torch.Size([2, 4])</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4)<br>c = a[:, 1:2]<br>print(c.shape)&nbsp; # 输出是什么？</div>
<div class="separator"></div>
<div class="field_1">torch.Size([2, 1, 4])。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4, 5)<br><br># 等价的索引方式<br>b1 = a[..., 2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 等价于什么？</div>
<div class="separator"></div>
<div class="field_1">等价于&nbsp;a[:, :, :, 2]。直接列出所有维度的索引。<br>&nbsp;&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4, 5)<br><br>b1 = a[..., 2]&nbsp;&nbsp;<br>print(b1.shape)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 输出是什么？</div>
<div class="separator"></div>
<div class="field_1">torch.Size([2, 3, 4])</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">省略号（Ellipsis）... 在多维张量中 的作用是什么？【这个符号用来表示多个什么？】</div>
<div class="separator"></div>
<div class="field_1">当你不想明确列出所有维度的索引时，可以使用 ... 来表示多个 :。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>整数索引：</div>效果：移除被索引的维度。<br>a[:, 1] -&gt; 是什么意思？<br></div>
<div class="separator"></div>
<div class="field_1">移除第1维。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>mxbai-embed-large 是由哪个平台提供的嵌入模型， 是由 哪个公司开发？</div></div>
<div class="separator"></div>
<div class="field_1">Ollama ，<span style="color: rgb(255, 0, 127);"><b>m</b></span>i<span style="color: rgb(255, 0, 127);"><b>x</b></span>edbread.<b><span style="color: rgb(255, 0, 127);">ai</span></b> 。(mxbai)</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>mxbai-embed-large 是一个什么模型？</div></div>
<div class="separator"></div>
<div class="field_1">强大的文本嵌入模型。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>mxbai-embed-large&nbsp;是一种嵌入模型，专为处理自然语言处理（NLP）任务而设计。它的主要功能是将文本数据转换为向量嵌入，是因为这些向量能够怎么样，从而在各种应用中实现高效的什么和什么用途？</div></div>
<div class="separator"></div>
<div class="field_1">能够捕捉<b><span style="color: rgb(255, 0, 127);">文本的语义特征</span></b>，文本<span style="color: rgb(255, 0, 127);"><b>比较</b></span>和<span style="color: rgb(255, 0, 127);"><b>检索</b></span>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">嵌入模型（embedding model）的作用是什么？<div></div></div>
<div class="separator"></div>
<div class="field_1">将输入文本、单词、句子或其他类型的数据映射到一个向量空间中。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">嵌入模型的训练目标是什么？【让相似的内容学到什么样的向量表示？】<br><div></div></div>
<div class="separator"></div>
<div class="field_1">目标是让相似内容学到相近的向量表示，同时在语义或语境上差异较大的内容得到相对较远的向量距离。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">嵌入模型将不同单词映射到向量空间中，可以通过那两种方式来度量语义相似度。<div></div></div>
<div class="separator"></div>
<div class="field_1">余弦相似度或欧几里得距离。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">词嵌入（Word Embeddings）是静态表示，表示什么意思？<div></div></div>
<div class="separator"></div>
<div class="field_1">同一个词在任何上下文中都具有相同的向量表示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">词嵌入（Word Embeddings）是静态表示，缺点是无法捕捉什么？<div></div>【不同什么中的什么性？】</div>
<div class="separator"></div>
<div class="field_1">无法捕捉词语在<b><span style="color: rgb(255, 0, 127);">不同上下文中的多义性</span></b>（即同一个词在不同语境下可能有不同的含义）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">上下文嵌入（Contextual Embeddings）<br>定义是什么？【根据不同的什么使用什么样的向量】</div>
<div class="separator"></div>
<div class="field_1">上下文嵌入根据词语在特定上下文中的使用情况生成动态的向量表示，同一个词在不同上下文中会有不同的向量。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">上下文嵌入（Contextual Embeddings） 是动态表示，如何理解？【同一词在不同的什么中具有不同的什么？】</div>
<div class="separator"></div>
<div class="field_1">同一个词在不同的句子或语境中具有不同的向量表示，能够反映其在具体上下文中的含义。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">静态词嵌入的三种模型分别是什么？</div>
<div class="separator"></div>
<div class="field_1">Word2Vec、GloVe和FastText。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">Word2Vec、GloVe、FastText 的词嵌入向量 共同的特点是什么？【是静态的还是动态的？是固定的还是动态的？在不同文本中的表示是怎么样的？】</div>
<div class="separator"></div>
<div class="field_1"><li><strong><span style="color: rgb(255, 0, 127);">固定</span>向量</strong>：在训练完成后，<span style="color: rgb(255, 0, 127);"><b>同一个词</b></span>在<b><span style="color: rgb(255, 0, 127);">不同文本中</span></b>的向量表示是相同的。</li><li><strong><span style="color: rgb(255, 0, 127);">静态</span>嵌入</strong>：<b><span style="color: rgb(255, 0, 127);">无法根据具体上下文</span></b>调整向量表示。</li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">Word2Vec：通过那两种方式训练得到？</div>
<div class="separator"></div>
<div class="field_1">跳字模型（Skip-gram）或连续词袋模型（CBOW）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">GloVe（Global Vectors for Word Representation）：基于什么来训练得到的？</div>
<div class="separator"></div>
<div class="field_1">基于词共现统计信息，通过矩阵分解方法训练得到。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">FastText：是谁的升级，升级指的是考虑了什么？解决了什么问题？</div>
<div class="separator"></div>
<div class="field_1">Word2Vec，考虑了词内部的子词（n-gram）信息。解决了未登录词（OOV）问题。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><strong>FastText 是如何处理</strong>未登录词（OOV）的问题？【组合什么生成什么？】</div>
<div class="separator"></div>
<div class="field_1">由于考虑了子词信息，可以通过<b><span style="color: rgb(255, 0, 127);">组合已知子词的向量</span></b>来生成未登录词的向量表示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">Word2Vec、GloVe、FastText 的词嵌入向量是固定的，这里“固定”指的是什么意思？</div>
<div class="separator"></div>
<div class="field_1">即同一个词在不同文本中的向量表示是相同的。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PromptTemplate 这个类里面的input_variables参数是什么类型？</div>
<div class="separator"></div>
<div class="field_1">字符串列表。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PromptTemplate 这个类里面的template参数是什么类型？</div>
<div class="separator"></div>
<div class="field_1">字符串。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在 PyTorch中，索引操作的作用是什么？【访问哪里的什么？】</div>
<div class="separator"></div>
<div class="field_1">用于访问和操作张量中的特定元素或子张量。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在 PyTorch中，索引操作可以分为两种主要类型，分别是什么？</div>
<div class="separator"></div>
<div class="field_1"><li><strong>整数索引（Integer Indexing）</strong></li><li><strong>切片索引（Slice Indexing）</strong></li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">使用整数索引会造成什么样的结果？</div>
<div class="separator"></div>
<div class="field_1">减少维度：使用整数索引时，被索引的维度会被移除。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4)&nbsp; # 形状为 (2, 3, 4)<br>b = a[:, 1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 对第1维使用整数索引1<br>print(b.shape)&nbsp;<br>输出是什么？</div>
<div class="separator"></div>
<div class="field_1">输出: torch.Size([2, 4])。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">切片索引（Slice Indexing）的语法是什么？以及目的是什么?</div>
<div class="separator"></div>
<div class="field_1">切片语法（如 start:stop）<br>开始索引，冒号，结束索引。<br>来选择范围内的元素。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">切片索引（Slice Indexing）选择的范围只有一个元素，被索引的维度会有什么变化？</div>
<div class="separator"></div>
<div class="field_1">被索引的维度依然会被保留，不会被删除。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4)&nbsp; # 形状为 (2, 3, 4)<br>c = a[:, 1:2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 对第1维使用切片1:2<br>print(c.shape)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>输出的结果是什么？</div>
<div class="separator"></div>
<div class="field_1">&nbsp;# 输出: torch.Size([2, 1, 4])。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在 PyTorch 中，当你对张量进行索引时，使用整数索引 以及 切片索引，分别对维度的影响是什么？</div>
<div class="separator"></div>
<div class="field_1">使用整数索引会减少相应维度的维数，而使用切片（slice）则可以保留维度。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4)<br>print(a[:, 1].shape)&nbsp; # 输出是什么？</div>
<div class="separator"></div>
<div class="field_1">torch.Size([2, 4])</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">a = torch.randn(2, 3, 4)<br>a[:, 1] 和 a[:, 1:2] 分别的形状是什么？</div>
<div class="separator"></div>
<div class="field_1"><li><strong><code>a[:, 1]</code></strong> 使用整数索引，<strong>移除</strong>第1维，结果形状为 <code>[2, 4]</code>。</li><li><strong><code>a[:, 1:2]</code></strong> 使用切片索引，<strong>保留</strong>第1维，结果形状为 <code>[2, 1, 4]</code>。</li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在大模型的生成任务中，出现“大模型复读机”现象通常是指什么现象？</div>
<div class="separator"></div>
<div class="field_1">模型在连续输出或长文本场景下不断重复已生成的内容或关键短语。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在大模型的生成任务中，出现“大模型复读机”现象，调整什么的角度进行优化？</div>
<div class="separator"></div>
<div class="field_1">惩罚系数（Penalty Coefficients）的角度。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在大模型的生成任务中，出现“大模型复读机”现象，从惩罚系数（Penalty Coefficients）的角度进行优化，涉及哪两种方法？</div>
<div class="separator"></div>
<div class="field_1">频率惩罚（Frequency Penalty）和存在惩罚（Presence Penalty）两方面。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>频率惩罚（Frequency Penalty）</div>定义：频率惩罚用于什么情况？【在文本生成过程中控制单词的什么】<br></div>
<div class="separator"></div>
<div class="field_1">用于控制某些词语或短语在文本生成过程中的重复使用次数。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>频率惩罚（Frequency Penalty）</div>每当一个词语在模型输出中已经出现过一定次数，模型会怎么样？【会降低什么？】<br></div>
<div class="separator"></div>
<div class="field_1">会在后续预测时降低该词再次出现的概率，从而抑制无意义的重复。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div>存在惩罚（Presence Penalty）</div>定义：存在惩罚针对的是什么？<br></div></div>
<div class="separator"></div>
<div class="field_1">词语是否已经出现过，而非出现的次数多少。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div>存在惩罚（Presence Penalty）</div>什么情况下，模型会受到一定的惩罚？<br></div></div>
<div class="separator"></div>
<div class="field_1">一旦某个词语在文本中已经出现，无论出现次数多少，模型都会受到一定的惩罚，使得该词再次出现的概率有所降低。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div>缩放温度（Temperature）<br></div></div><div>温度过低时，温度过高 分别会有什么效果？<br></div></div>
<div class="separator"></div>
<div class="field_1">温度过低时，模型更倾向于重复出现的高概率词；<br>温度过高则会使模型更具创意但风险在于输出不稳定，破坏上下文连贯性。可与惩罚系数搭配调参。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div>如Top-k或Top-p（Nucleus Sampling），可以减少模型陷入什么模式，从而降低“复读机”现象。<br></div></div></div>
<div class="separator"></div>
<div class="field_1">固定模式。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div>除了惩罚系数这个方式可以解决“大模型复读机”问题，还有哪两个方式可以解决？<br></div></div></div>
<div class="separator"></div>
<div class="field_1">缩放温度（Temperature）以及&nbsp;采样策略：如Top-k或Top-p。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div>频率惩罚（Frequency Penalty）和 存在惩罚（Presence Penalty），分别的区别是什么？</div></div>【分别根据什么来做出惩罚？ 】</div>
<div class="separator"></div>
<div class="field_1">频率惩罚（Frequency Penalty）会根据某个词在生成的文本里出现的频率来给它打“折扣”。<br><div>存在惩罚（Presence Penalty）关注的是‘这个词有没有出现过’，不管它出现了几次，只要它出现过，就对后续再次出现做一定的惩罚。</div><br></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">在实际项目中，如何解决模型产生复读机的现象？【解决思路，先是惩罚系数，然后这个系数的使用过程，然后再是哪两个策略？】</div>
<div class="separator"></div>
<div class="field_1">在实际项目中，一般我会先把惩罚系数设置到一个相对温和的数值，然后观察文本输出是否有重复。如果依旧重复多，就往上调一点，直到找到既不影响上下文连贯，又能减少重复的最佳平衡点。同时也可以配合调整Temperature，或者用Top-k、Top-p这些采样方式，帮助模型摆脱‘复读机’的窘境。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div><div><div><div><div><div><div><div>list1= [1,2]&nbsp;</div><div>list1 [-3] 和 list1 [-3 :]</div><div>分别的结果是什么？</div><div></div></div></div></div></div></div></div></div></div></div>
<div class="separator"></div>
<div class="field_1">使用 list1[-3] 时，会发生索引越界错误。<br>使用切片 list1[-3:] 时，不会报错，原因是切片操作在 Python 中有一种“宽松”的规则。切片会尽量返回有效的部分，即使索引越界。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div><div><div><div><div><div><div><div><div>list1= [1,2]&nbsp;</div><div>list1 [-3] 和 list1 [-3 :]</div><div>使用切片 list1[-3:] 时，为什么不会报错？</div><div></div></div></div></div></div></div></div></div></div></div>
<div class="separator"></div>
<div class="field_1">原因是切片操作在 Python 中有一种“宽松”的规则。切片会尽量返回有效的部分，即使索引越界。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>常见的两种距离度量方法是什么？<br></div><div></div></div>
<div class="separator"></div>
<div class="field_1">欧式距离（Euclidean distance）和曼哈顿距离（Manhattan distance）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>欧式距离（Euclidean distance）和曼哈顿距离（Manhattan distance）他们之间的区别是什么？<br></div><div></div></div>
<div class="separator"></div>
<div class="field_1">欧式距离，空间中两点之间的“直线”距离。<br>曼哈顿距离，曼哈顿岛的街道布局，街道呈网格状，因此只能沿着垂直和水平方向行走，而不能走斜线。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PyCharm 在添加已有的Conda 环境时，需要设置的主要是两个部分，分别是什么？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>Conda Executable</li><li>Use existing environment</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PyCharm 在添加已有的Conda 环境时，需要设置的主要是两个部分，Conda Executable：这个字段需要指定 哪个文件的位置，通常是哪个目录？</div>
<div class="separator"></div>
<div class="field_1">Conda Executable：这个字段需要指定 <span style="color: rgb(255, 0, 127);"><b>Conda 可执行文件conda.bat </b></span>的位置，通常是 <b><span style="color: rgb(255, 0, 127);">Conda 安装目录</span></b>下的 D:\ProgramData\<span style="color: rgb(255, 0, 127);"><b>Anaconda3\condabin\</b></span>conda.bat 文件</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">conda.bat 文件是 Conda 的核心管理工具，它负责什么操作？</div>
<div class="separator"></div>
<div class="field_1">负责<b><span style="color: rgb(255, 0, 127);">激活和管理</span></b>环境，安装包等操作。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">无论您的虚拟环境在哪里，conda.bat 文件的位置是固定的，这是为什么？</div>
<div class="separator"></div>
<div class="field_1">因为它是 Conda 安装的一部分。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PyCharm 在添加已有的Conda 环境时，需要设置的主要是两个部分，Use existing environment：这个字段，是否需要手动指定到环境目录下的 python.exe，以及为什么？</div>
<div class="separator"></div>
<div class="field_1">无需手动指定到环境目录下的 python.exe，只需要确定这个虚拟环境的名称就行，因为PyCharm 会自动从 Conda 环境中找到相应的 python.exe 并将其作为解释器。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">只需选择已创建的虚拟环境即可，PyCharm 会根据 哪个文件 自动加载该环境的 Python 解释器。<br><img src="images/paste-7f68b6b1d0a8e033c9dde4c450918d864e410c9a.jpg"></div>
<div class="separator"></div>
<div class="field_1">PyCharm 会根据 <b><span style="color: rgb(255, 0, 127);">conda.bat</span></b>【也就是前面指定的conda可执行文件】 自动加载该环境的 Python 解释器。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">condabin 目录中的 activate.bat 文件是什么作用以及对应哪个cmd命令?</div>
<div class="separator"></div>
<div class="field_1">activate.bat 是 Conda 用于<span style="color: rgb(255, 0, 127);"><b>激活环境的批处理脚本</b></span>，它会在您运行 <b><span style="color: rgb(255, 0, 127);">conda activate &lt;env_name&gt; </span></b>时被调用。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">condabin 目录包含 什么工具？</div>
<div class="separator"></div>
<div class="field_1">Conda 的核心管理工具。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">conda.bat 这个文件通常对应的路径是什么？</div>
<div class="separator"></div>
<div class="field_1">D:\ProgramData\Anaconda3\condabin\conda.bat</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">conda.bat 这个文件通常包含了哪两个常见的cmd命令？</div>
<div class="separator"></div>
<div class="field_1"><ul><li>conda activate</li><li>conda install</li></ul><div></div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">conda.bat 是否依赖于具体的虚拟环境？</div>
<div class="separator"></div>
<div class="field_1">不依赖，因为他是全局脚本。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">conda.bat 这个文件是用于什么的脚本？</div>
<div class="separator"></div>
<div class="field_1">用于 Conda <b><span style="color: rgb(255, 0, 127);">环境管理的批处理</span></b>脚本。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">PyCharm 会通过哪个文件来运行 Conda 命令？</div>
<div class="separator"></div>
<div class="field_1">conda.bat。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">"Conda Executable" 选择框中指定环境的路径吗？<br><img src="images/paste-9bbdab95c170f017b33471e434558aa3f7910c1e.jpg"></div>
<div class="separator"></div>
<div class="field_1">不是环境的路径，而是指定 conda.bat的路径。<br><img src="images/paste-90b008b71c67f954ab1e27f13e7e905a8243faa1.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">"Conda Executable" 以及 “use existing environment”&nbsp;<br>这两个选项他们之间的关联是什么？<img src="images/paste-9bbdab95c170f017b33471e434558aa3f7910c1e.jpg"></div>
<div class="separator"></div>
<div class="field_1">Conda Executable是要指定conda管理工具，<br>use existing environment是要指定 特定的虚拟环境。<br><br>然后Pycharm利用前面指定的conda管理工具来管理和激活后面选择的特定的虚拟环境。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">为何只需选择特定虚拟环境的名称，而无需指定该环境中具体的 Python.exe 文件路径呢？<br><img src="images/paste-9bbdab95c170f017b33471e434558aa3f7910c1e.jpg"></div>
<div class="separator"></div>
<div class="field_1">这是因为 PyCharm 的操作更为友好便捷，它会<b><span style="color: rgb(255, 0, 127);">依据指定的虚拟环境自动搜索对应的 python.exe 文件</span></b>，无需手动查找文件位置。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">conda.bat 是否是静态的，不同项目里面的conda.bat&nbsp;是否不一样？</div>
<div class="separator"></div>
<div class="field_1">是静态的，conda.bat是全局的，不论有多少项目，conda.bat只有一个。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">Prompt Tuning是一种通过修改什么来优化模型性能的方法？</div>
<div class="separator"></div>
<div class="field_1">输入提示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">NER项目里面data文件夹下面，通常存放哪两个子文件夹以及分别作用是什么？</div>
<div class="separator"></div>
<div class="field_1"><li><code><b><span style="color: rgb(255, 0, 127);">raw</span></b>/</code>：存放<b><span style="color: rgb(255, 0, 127);">原始数据</span></b>文件（如你提到的<span style="color: rgb(255, 0, 127);"><b>jsonl</b></span>文件），这类数据通常未经任何处理。</li><li><code><b><span style="color: rgb(255, 0, 127);">processed</span></b>/</code>：存放处理过的数据，例如分词后的文本数据和标签已经转化为<b><span style="color: rgb(255, 0, 127);">BIO标注格式的文件</span></b>。你可以用该文件直接训练模型。</li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">NER项目里面model文件夹下面，bert_model这个文件夹放什么？&nbsp;【将什么下载下来放在这里。】</div>
<div class="separator"></div>
<div class="field_1">&nbsp;将BERT预训练模型下载并存储在这个文件夹中。<br>可以存放pytorch_model.bin（权重文件）和config.json（BERT模型配置）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">NER项目里面model文件夹下面，bert-base-chinese 里面有两个重要文件分别是什么？</div>
<div class="separator"></div>
<div class="field_1">pytorch_model.bin（模型权重文件）和config.json（BERT模型配置）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">NER项目里面model文件夹下面，bert-base-chinese 里面有两个重要文件分别是（权重文件）和（BERT模型配置），对应的文件名称是什么？</div>
<div class="separator"></div>
<div class="field_1">pytorch_model.bin，<br>config.json。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>NER项目里面model文件夹下面，bert-base-chinese 里面有两个重要文件分别是 pytorch_model.bin，<br></div><div>config.json。</div><div>对应的作用是什么？</div></div>
<div class="separator"></div>
<div class="field_1">（权重文件）和（BERT模型配置）&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>NER项目里面model文件夹下面， 除了bert_model文件夹以外，还有哪些文件？</div>【4个】</div>
<div class="separator"></div>
<div class="field_1"><li><code><b><span style="color: rgb(255, 0, 127);">model</span></b>.py</code>：这里是你实现BERT+BiLSTM+CRF模型的地方，定义模型架构。</li><li><code><b><span style="color: rgb(255, 0, 127);">train</span></b>.py</code>：训练脚本，定义了模型的训练流程，包括数据加载、损失计算、优化等。</li><li><code><b><span style="color: rgb(255, 0, 127);">evaluate</span></b>.py</code>：评估脚本，用于在验证集或测试集上评估模型的表现。</li><li><code><b><span style="color: rgb(255, 0, 127);">inference</span></b>.py</code>：推理脚本，用于加载训练好的模型并对新数据进行预测。</li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">模型使用的三个数据集，训练集，测试集，真实场景的数据，分别被哪三个py文件使用？</div>
<div class="separator"></div>
<div class="field_1"><li><code><b><span style="color: rgb(255, 0, 127);">train</span></b>.py</code>：训练脚本，定义了模型的训练流程，包括数据加载、损失计算、优化等。</li><li><code><b><span style="color: rgb(255, 0, 127);">evaluate</span></b>.py</code>：评估脚本，用于在验证集或测试集上评估模型的表现。</li><li><code><b><span style="color: rgb(255, 0, 127);">inference</span></b>.py</code>：推理脚本，用于加载训练好的模型并对新数据进行预测。</li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">evaluate.py 这个文件是什么脚本，然后用于哪个数据集？</div>
<div class="separator"></div>
<div class="field_1">evaluate.py：<b><span style="color: rgb(255, 0, 127);">评估</span></b>脚本，用于在验证集或<span style="color: rgb(255, 0, 127);"><b>测试集</b></span>上评估模型的表现。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">inference.py 这个文件是什么脚本，然后用于哪个数据集？</div>
<div class="separator"></div>
<div class="field_1">inference.py：<span style="color: rgb(255, 0, 127);"><b>推理</b></span>脚本，用于加载训练好的模型并对<b><span style="color: rgb(255, 0, 127);">新数据进行预测</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">model.py：这个文件里面定义了什么？</div>
<div class="separator"></div>
<div class="field_1">模型架构。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">scripts 这个文件夹下面存放的那两个文件以及分别是什么作用？</div>
<div class="separator"></div>
<div class="field_1"><li><code><span style="color: rgb(255, 0, 127);"><b>preprocess_data</b></span>.py</code>：数据预处理脚本，用于读取<span style="color: rgb(255, 0, 127);"><b>raw</b></span>数据并将其转换为<b><span style="color: rgb(255, 0, 127);">BIO</span></b>格式标签。</li><li><code><span style="color: rgb(255, 0, 127);"><b>data_loader</b></span>.py</code>：定义<span style="color: rgb(255, 0, 127);"><b>数据加载器</b></span>（例如使用<code>torch.utils.data.DataLoader</code>），确保数据能够<b><span style="color: rgb(255, 0, 127);">正确地批量读取并传递给模型。</span></b></li><li></li></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">scripts 这个文件夹下面的<br>preprocess_data.py文件的作用是什么？</div>
<div class="separator"></div>
<div class="field_1">数据预处理脚本，用于读取raw数据并将其转换为BIO格式标签。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">scripts 这个文件夹下面的<br>data_loader.py文件的作用是什么？【定义了什么？确保数据可以被怎么样读取？读取完传递给谁？】</div>
<div class="separator"></div>
<div class="field_1">定义数据加载器（例如使用torch.utils.data.DataLoader），确保数据能够正确地批量读取并传递给模型。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">config.py：配置文件，存储什么数据？</div>
<div class="separator"></div>
<div class="field_1">训练的超参数（例如学习率、batch size、epoch数量等）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">config.py：配置文件，存储训练的超参数，具体有哪些？</div>
<div class="separator"></div>
<div class="field_1">（例如学习率、batch size、epoch数量等）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">label_map.json：这是什么文件？以及它的作用是将什么映射成什么？</div>
<div class="separator"></div>
<div class="field_1"><span style="color: rgb(255, 0, 127);"><b>标签映射</b></span>文件，将<span style="color: rgb(255, 0, 127);"><b>实体类别</b></span>（例如“Organization”）映射到<b><span style="color: rgb(255, 0, 127);">整数标签</span></b>（如0、1、2等）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>checkpoints/：它的作用是什么？</div><div></div>【在什么过程中保存的什么？】</div>
<div class="separator"></div>
<div class="field_1">存放训练中保存的模型文件（例如每个epoch后保存的模型权重），以便后续加载并继续训练或进行推理。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>在NER任务中， 文本预处理是否会保留标点，以及为什么？</div><div></div></div>
<div class="separator"></div>
<div class="field_1">不会，以便更好地识别实体边界。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>BIO标注里面，这三个字母的含义？</div><div></div></div>
<div class="separator"></div>
<div class="field_1">Begin-Inside-Outside。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>标签信息（例如[1,5,"Organization"]），使用BIO格式，怎么进行标记呢？</div><div></div></div>
<div class="separator"></div>
<div class="field_1">为每个字符分配一个标签。索引为1的位置标记B-ORG，索引2~5位置标记I-ORG，其余的位置标记为O。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">模型在训练过程中会被保存存放在哪个文件夹下面？</div>
<div class="separator"></div>
<div class="field_1">checkpoints</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>BERT的tokenizer处理分词后可能出现的子词问题，这个子词问题是什么意思？</div><div></div></div>
<div class="separator"></div>
<div class="field_1">BERT的tokenizer会将一个词拆分成多个subword token。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>data_loader.py&nbsp;这个文件它的功能是什么？<div></div></div><div></div>【将处理后的数据转换成哪两种格式？】</div>
<div class="separator"></div>
<div class="field_1">负责将处理后的数据（如已分词和标注的文本）转化为torch.utils.data.<b><span style="color: rgb(255, 0, 127);">Dataset</span></b>和<span style="color: rgb(255, 0, 127);"><b>DataLoader</b></span>格式，以便在训练和评估过程中批量加载。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>data_loader.py&nbsp;这个文件是连接什么和什么的桥梁？<div></div></div><div></div></div>
<div class="separator"></div>
<div class="field_1">是连接数据和模型训练的桥梁。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>data_loader.py&nbsp;这个文件里面，创建一个NERDataset类，继承自哪个类，以及实现哪两个方法？<div></div></div><div></div></div>
<div class="separator"></div>
<div class="field_1">继承自torch.utils.data.Dataset，实现__getitem__和__len__方法。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>model.py是定义 BERT+BiLSTM+CRF模型的地方。这个模型将处理经过谁处理后的数据？<div></div></div><div></div></div>
<div class="separator"></div>
<div class="field_1">tokenizer。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0"><div>模型的定义决定了模型的哪两方面？<div></div></div><div></div></div>
<div class="separator"></div>
<div class="field_1"><span style="color: rgb(255, 0, 127);"><b>网络结构</b></span>和各层之间的<b><span style="color: rgb(255, 0, 127);">连接</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">ner任务里面，<div>如果要写tokenizer.py：你需要将文本怎么样并处理标签的什么的逻辑。<div></div></div><div></div></div>
<div class="separator"></div>
<div class="field_1">将文本分词并处理标签的对齐逻辑。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">ner实体识别任务里面，<div>tokenizer.py 核心部分是对什么和什么进行对齐，确保分词后的每个什么都有正确的实体标签。&nbsp;<div></div></div><div></div></div>
<div class="separator"></div>
<div class="field_1">token和标签，分词后的subword都有正确的实体标签。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">ner任务里面，<div>&nbsp;BERT的tokenizer可能将词拆分成多个subword，需要怎么做以确保每个subword token都对应正确的什么？<div></div></div><div></div></div>
<div class="separator"></div>
<div class="field_1">扩展标签。正确的标签。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">下面的id2label是否是一个函数，以及为什么？<br>&nbsp; &nbsp; @property<br><br>&nbsp;&nbsp;&nbsp; def id2label(self):<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {id_: label for label, id_ in self.label2id.items()}</div>
<div class="separator"></div>
<div class="field_1">不是一个普通函数，是可以通过属性的方式来访问这个函数，也就是不用加小括号。<br>id2label 是一个 <b><span style="color: rgb(255, 0, 127);">属性</span></b>（使用了 @<span style="color: rgb(255, 0, 127);"><b>property 装饰器</b></span>），而不是一个普通的函数。使用 @property 装饰器的函数会被当作属性来访问。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">下面代码里面这个装饰器<b><span style="color: rgb(255, 0, 127);">@property</span></b>它的作用是什么？<br>&nbsp; &nbsp; @property
<br>&nbsp;&nbsp;&nbsp; def id2label(self):
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {id_: label for label, id_ in self.label2id.items()}</div>
<div class="separator"></div>
<div class="field_1">@property 将 id2label 转换成了一个属性访问的形式，你可以像访问类的属性一样访问它，而不需要加小括号。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">下面代码里面这个函数，<br>是通过这种方式config.model.<span style="color: rgb(255, 0, 127);"><b>id2label()</b></span> 访问，<br>还是通过config.model.<b><span style="color: rgb(255, 0, 127);">id2label</span></b>这种方式访问？<br>以及为什么？<br><br>&nbsp; &nbsp; @property
<br>&nbsp;&nbsp;&nbsp; def id2label(self):
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {id_: label for label, id_ in self.label2id.items()}</div>
<div class="separator"></div>
<div class="field_1">config.model.<b><span style="color: rgb(255, 0, 127);">id2label，<br></span></b>使用 @property 装饰器时，函数被视为属性来访问。访问属性时，不需要加小括号。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">@property 装饰器它的作用是什么？</div>
<div class="separator"></div>
<div class="field_1">将方法变成了一个可直接访问的属性。因此，你可以像访问一个变量一样直接访问它，而不需要加括号。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">通常来说， 不建议在&nbsp;config.py 中直接初始化&nbsp;tokenizer，原因是什么？</div>
<div class="separator"></div>
<div class="field_1"><div><div><div><div></div><div></div></div></div></div><ul><li>配置文件<span style="color: rgb(255, 0, 127);"><b>职责单一</b></span>：<span style="color: rgb(255, 0, 127);"><b>config</b></span>.py 主要用于存储<span style="color: rgb(255, 0, 127);"><b>配置参数</b></span>，而不是实例化对象。</li><li>避免依赖问题：<span style="color: rgb(255, 0, 127);"><b>config</b></span>.py 应该<span style="color: rgb(255, 0, 127);"><b>尽量轻量</b></span>，不应该依赖太多外部库。</li><li><span style="color: rgb(255, 0, 127);"><b>延迟</b></span>加载：tokenizer <span style="color: rgb(255, 0, 127);"><b>占用内存</b></span>，应该在<b><span style="color: rgb(255, 0, 127);">需要时才加载。</span></b></li></ul><div><div><div><div></div><div></div></div></div></div><div><div><div><div></div><div></div></div></div></div><div><div><div><div></div><div></div></div></div></div><br></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">通常来说， 不建议在&nbsp;config.py 中直接初始化&nbsp;tokenizer， 那么主流做法是在哪两个文件里面调用get_tokenizer来进行初始化tokenizer？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">主流做法：通常在具体的<b><span style="color: rgb(255, 0, 127);">模型文件或数据处理文件</span></b>中初始化&nbsp;tokenizer。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">如果在 Config 类中直接写 self.tokenizer = BertTokenizer.from_pretrained(...)，那么tokenizer&nbsp;什么时候会被初始化？</div>
<div class="separator"></div>
<div class="field_1">当你创建 Config 类的实例时，self.tokenizer 会被直接实例化，即 BertTokenizer.from_pretrained(...) 会在 Config 类的对象被初始化时立即执行。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">直接在 Config 类中实例化 tokenizer&nbsp;为什么会导致不必要的开销？</div>
<div class="separator"></div>
<div class="field_1">因为每次创建 Config 实例时都会初始化一次tokenizer。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">tokenizer.py&nbsp;这个文件里面写的这个函数存在什么问题，以及为什么<br>def get_tokenizer():
<br>&nbsp;&nbsp;&nbsp; """获取tokenizer实例"""
<br>&nbsp;&nbsp;&nbsp; return BertTokenizer.from_pretrained(
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config.model.tokenizer_name,
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **config.model.tokenizer_kwargs
<br>&nbsp;&nbsp;&nbsp; )</div>
<div class="separator"></div>
<div class="field_1">get_tokenizer() <span style="color: rgb(255, 0, 127);"><b>函数每次被调用</b></span>时都会执行 BertTokenizer.from_pretrained(...)，那么确实会每次都<span style="color: rgb(255, 0, 127);"><b>重新加载 tokenizer</b></span>，这会带来<b><span style="color: rgb(255, 0, 127);">不必要的内存消耗和性能损耗。</span></b></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">如果你的任务不是NER（命名实体识别）这种需要为每个token打标签的任务，那么通常情况下还 需要进行token和标签的对齐吗？</div>
<div class="separator"></div>
<div class="field_1">不需要。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">例如，BERT在处理NER时会将句子中的每个token都与什么进行映射。</div>
<div class="separator"></div>
<div class="field_1">一个标签（例如实体类型或O标签）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">对于文本分类任务，通常不会进行token与标签的对齐。你会将什么作为输入，并将其分配到一个什么？</div>
<div class="separator"></div>
<div class="field_1">整个句子作为输入，分配到一个类别。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">raw_data_dir 和 processed_data_dir&nbsp;分别是什么意思？</div>
<div class="separator"></div>
<div class="field_1">是原始数据和处理后数据的存储路径。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::1-22</div>
<div class="field_0">root_dir&nbsp;它的代码应该是什么？使用相对路径。</div>
<div class="separator"></div>
<div class="field_1"><div>root_dir = <b><span style="color: rgb(255, 0, 127);">Path(__file__).</span></b>parent.parent</div></div>
</div>

<script>
document.addEventListener('click', function(e) {
const container = e.target.closest('.video-container');
if (!container) return;

const placeholder = container.querySelector('.video-placeholder');
if (!placeholder) return;

const videoId = container.dataset.videoId;
const startParam = container.dataset.start || '';

const iframe = document.createElement('iframe');
iframe.width = '100%';
iframe.height = '100%';
iframe.src = `https://www.youtube.com/embed/${videoId}?${startParam.slice(1)}`;
iframe.title = 'YouTube video player';
iframe.frameBorder = '0';
iframe.style.position = 'absolute';
iframe.style.top = '0';
iframe.style.left = '0';
iframe.style.borderRadius = '15px';
iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
iframe.allowFullscreen = true;

placeholder.innerHTML = '';
placeholder.appendChild(iframe);
});
</script>

</div>
<div class="footer">Made by <a href="https://xxhk.org">Export Notes - XXHK</a></div>
</body>
</html>

